\documentclass{article}

\usepackage{amsmath, amssymb}
\usepackage[usenames,dvipsnames]{xcolor}

\newcommand{\RED}[1]{\textcolor{red}{#1}}
\newcommand{\TODO}[1]{\RED{[TODO: #1]}}

\newcommand{\rulename}{\textsc}
\newcommand{\rn}{\rulename}

\newcommand{\irule}[3]{\begin{array}{l}{~\small\mbox{(\rulename{#1})}}\\\;\frac{\begin{array}{c}#2\end{array}}{\begin{array}{l}#3\end{array}}\end{array}}
%\newcommand{\irule}[3]{\frac{\begin{array}{c}#2\end{array}}{\begin{array}{l}#3\end{array}}{~\small\mbox{(\rulename{#1})}}}

\newcommand{\labelFont}{\texttt}
\newcommand{\cursorColor}{LimeGreen}

\newcommand{\lbl}{\ensuremath{\mathit{lbl}}}
\newcommand{\lbls}{\ensuremath{\mathit{lbls}}}
\newcommand{\Top}{\ensuremath{\labelFont{Top}}}
\newcommand{\Group}{\ensuremath{\labelFont{Group}}}
\newcommand{\Invalid}{\ensuremath{\labelFont{Invalid}}}
\newcommand{\Unclosed}{\ensuremath{\labelFont{Unclosed}}}

\newcommand{\tm}{\ensuremath{\mathtt{tm}}}
\newcommand{\tms}{\ensuremath{\mathtt{tms}}}

\newcommand{\Tm}{\ensuremath{\check{\tm}}}
\newcommand{\Tms}{\ensuremath{\check{\tms}}}

\newcommand{\Tmc}{\ensuremath{\overset{ \textcolor{\cursorColor}{\bowtie}}{\tm}}}
\newcommand{\Tmcs}{\ensuremath{\overset{\textcolor{\cursorColor}{\bowtie}}{\tms}}}

\newcommand{\Tmx}{\ensuremath{\hat{\tm}}}
\newcommand{\Tmxs}{\ensuremath{\hat{\tms}}}

%% Actions
\newcommand{\action}{\ensuremath{\alpha}}
\newcommand{\add}[1]{\ensuremath{\texttt{add}~#1}}
\newcommand{\push}[1]{\ensuremath{\texttt{push}~#1}}
\newcommand{\pop}[1]{\ensuremath{\texttt{pop}~#1}}
\newcommand{\trypop}[1]{\ensuremath{\texttt{trypop}~#1}}
\newcommand{\seq}[1]{\ensuremath{\texttt{seq}~#1}}
\newcommand{\term}[1]{\ensuremath{\texttt{term}~#1}}
\newcommand{\invalid}{\ensuremath{\texttt{invalid}}}
\newcommand{\unclosed}{\ensuremath{\texttt{unclosed}}}
\newcommand{\done}{\ensuremath{\texttt{done}}}

%% Cursors and matching
\newcommand{\cursor}{\ensuremath{\downarrow}}
\newcommand{\mstart}{\ensuremath{\textcolor{\cursorColor}{\rhd}}}
\newcommand{\mend}{\ensuremath{\textcolor{\cursorColor}{\lhd}}}

\newcommand{\bindings}{\ensuremath{\mathcal{M}}}
\newcommand{\nobindings}{\ensuremath{\emptyset}}
\newcommand{\extend}[2]{\ensuremath{#1\cup #2}}
\newcommand{\concat}{\ensuremath{\mathop{+\!\!+}}}

\newcommand{\select}[1]{\mstart\colorbox{\cursorColor}{$#1$}\mend}

\newcommand{\steps}[1]{\ensuremath{\xrightarrow{#1}}}
\newcommand{\matches}[4]{\ensuremath{#1 \vdash #2 \Rightarrow #3 ~|~ #4}}
\newcommand{\xmatches}[4]{\ensuremath{
    \begin{array}{r@{\hspace{4pt}}c@{\hspace{4pt}}l}%
      #1 & \vdash & #2 \Rightarrow\\
         &        & #3 ~|~ #4
    \end{array}}}

\newcommand{\matchesm}[5]{\ensuremath{#1 \vdash #2 : #3 \Rightarrow #4 ~|~ #5}}
\newcommand{\xmatchesm}[5]{\ensuremath{
    \begin{array}{r@{\hspace{4pt}}c@{\hspace{2pt}}l}
      #1 & \vdash & #2 : #3\Rightarrow\\
         &        & #4 ~|~ #5
    \end{array}}}

\newcommand{\wfp}[3]{\ensuremath{#1 \vdash #2 : #3}}

%% Patterns
\newcommand{\pseq}[2]{\ensuremath{#1 \cdot #2}}
\newcommand{\por}[2]{\ensuremath{#1/#2}}
\newcommand{\pand}[2]{\ensuremath{#1\&#2}}
\newcommand{\children}[2]{\ensuremath{#1} \Downarrow #2}
\newcommand{\pnot}[1]{\ensuremath{\lnot #1}}
\newcommand{\maybe}[1]{\ensuremath{#1?}}
\newcommand{\many}[1]{\ensuremath{#1^*}}
\newcommand{\any}{\ensuremath{\text{\underline{\hspace{0.6em}}}}}
\newcommand{\none}{\ensuremath{\mathbf{none}}}
\newcommand{\bind}[2]{\ensuremath{#1@#2}}
\newcommand{\paction}[2]{\ensuremath{#1\mathop{\circ} #2}}
\newcommand{\fb}[1]{\ensuremath{\mathop{\rightarrow}(#1)}}
\newcommand{\nfb}[1]{\ensuremath{\mathop{\not\rightarrow}(#1)}}
\newcommand{\pin}[1]{\ensuremath{\mathit{In}(#1)}}
\newcommand{\pstart}{\ensuremath{\mathit{Start}}}
\newcommand{\pend}{\ensuremath{\mathit{End}}}

\newcommand{\arrayheading}[2]{\multicolumn{#1}{l}{\mbox{#2}}}

\synctex=1

\begin{document}

\section{Parsing in Trieste}

\[
  \begin{array}{rcl}
    \arrayheading{3}{Labels}\\
    \lbl  & \in & \{\Top, \Group, \Invalid, \Unclosed\}\cup \mathcal{L} \\
    \lbls & ::= & \lbl_1 .. \lbl_n\\
    \\
    \arrayheading{3}{Terms}\\
    \tm  & ::= & (\lbl~\tms) \\
    \tms & ::= & \tm ~ \tms ~|~ \epsilon \\
    \\
    \arrayheading{3}{Terms with a single cursor}\\
    \Tm  & ::= & (\lbl~\Tms)\\
    \Tms & ::= & \tm ~ \Tms ~|~ \Tm ~|~ \cursor\\
    \\
    \arrayheading{3}{Contexts (shallow)}\\
    \Tm[\bullet] & ::= & (\lbl~\Tms[\bullet])\\
    \Tms[\bullet] & ::= & \tm ~ \Tms[\bullet] ~|~ \bullet\\
    \\
    \arrayheading{3}{Actions}\\
    \action & ::= & \add{\lbl}\\
            & ~|~ & \push{\lbl}\\
            & ~|~ & \pop{\lbl}\\
            & ~|~ & \seq{\lbl}\\
            & ~|~ & \term{\lbls}\\
            & ~|~ & \trypop{\lbl}\\
            & ~|~ & \invalid\\
            & ~|~ & \unclosed\\
            & ~|~ & \done\\
  \end{array}
\]

A term \tm{} is an $n$-ary tree where each node has a label \lbl.
%
During parsing, terms \Tm{} have a single cursor \cursor{} in them,
always ``furthest to the right'' in the tree.
%
We use $\Tm[\bullet]$ to denote a term whose right-most child is a
hole $\bullet$ that can be filled with a sequence of terms.

We use the rule \rn{ctx} to ``zoom in'' close enough to the cursor
to apply a rule. Actions \term{} and \done{} are always applied to
the whole term and are therefore excluded from being applied in a
context:


\[
\irule{ctx}{
\Tm_1 \steps{\action} \Tm_2\\
\action \notin \{\term, \done\}
}{
\Tm[\Tm_1] \steps{\action} \Tm[\Tm_2]
}
\]

The action \add{\lbl} will add a \lbl-term to a group and
advance the cursor, creating a new group and moving inside it if
the cursor is not already inside one:

\[
  \begin{array}{c}
    \irule{add-in}{}{
    (\Group~\Tms[\cursor]) \steps{\add{\lbl}} (\Group~\Tms[(\lbl) \cursor])
    }
    \\\\

    \irule{add-create}{
    \lbl' \neq \Group
    }{
    (\lbl'~\Tms[\cursor]) \steps{\add{\lbl}} (\lbl'~\Tms[(\Group~(\lbl) \cursor)])
    }
  \end{array}
\]

Pushing a label adds a term (creating a group if needed) and moves
the cursor inside it:

\[
  \begin{array}{c}
    \irule{push-in}{}{
    (\Group~\Tms[\cursor]) \steps{\push{\lbl}} (\Group~\Tms[(\lbl~\cursor)])
    }
    \\\\

    \irule{push-create}{
    \lbl' \neq \Group
    }{
    (\lbl'~\Tms[\cursor]) \steps{\push{\lbl}} (\lbl'~\Tms[(\Group~(\lbl~\cursor))])
    }
  \end{array}
\]

The action \pop{\lbl} moves the cursor out of the innermost term,
assuming its label is \lbl. If the label does not match, an
error is reported (defined below):

\[
  \begin{array}{c}
    \irule{pop-ok}{
    (\lbl'~\Tms[(\lbl~\Tms'[\cursor])]) \steps{\trypop{\lbl}} \Tm
    }{
    (\lbl'~\Tms[(\lbl~\Tms'[\cursor])]) \steps{\pop{\lbl}} \Tm
    }
    \\\\

    \irule{pop-fail}{
    \lbl'' \neq \lbl\\
    (\lbl''~\Tms'[\cursor]) \steps{\invalid} \Tm
    }{
    (\lbl'~\Tms[(\lbl''~\Tms'[\cursor])]) \steps{\pop{\lbl}}
    (\lbl'~\Tms[\Tm])
    }
  \end{array}
\]

Popping is done via an auxiliary action \trypop{\lbl} which does
nothing on a label mismatch:

\[
  \begin{array}{c}
    \irule{trypop-ok}{}{
    (\lbl'~\Tms[(\lbl~\Tms'[\cursor])]) \steps{\trypop{\lbl}}
    (\lbl'~\Tms[(\lbl~\Tms'[\epsilon])~\cursor])
    }
    \\\\
    \irule{trypop-fail}{
    \lbl'' \neq \lbl
    }{
    (\lbl'~\Tms[(\lbl''~\Tms'[\cursor])]) \steps{\trypop{\lbl}}
    (\lbl'~\Tms[(\lbl''~\Tms'[\cursor])])
    }
  \end{array}
\]

Errors are reported by adding a term with the label \Invalid. If
the cursor is already next to an \Invalid-term, the extent of
that error is extended (currently just modeled as a no-op) rather
than adding another \Invalid-term:

\[
  \begin{array}{c}
    \irule{invalid-extend}{}{
    (\lbl~\Tms[(\Invalid)~\cursor]) \steps{\invalid}
    (\lbl~\Tms[(\Invalid)~\cursor])
    }
    \\\\

    \irule{invalid-empty}{
    (\lbl~\cursor) \steps{\add{\Invalid}} \Tm
    }{
    (\lbl~\cursor) \steps{\invalid} \Tm
    }
    \\\\

    \irule{invalid-non-empty}{
    \lbl' \neq \Invalid\\
    (\lbl~\Tms[(\lbl'~\Tms') \cursor]) \steps{\add{\Invalid}} \Tm
    }{
    (\lbl~\Tms[(\lbl'~\Tms') \cursor]) \steps{\invalid} \Tm
    }
  \end{array}
\]

The action \seq{\lbl} finishes the current group and makes it a
child of a \lbl-term, creating that term if it is not the parent
of the current group. Performing the \seq{}-action when not in a
group is an error:

\[
  \begin{array}{c}
    \irule{seq-in}{}{
    (\lbl~\Tms[(\Group~\Tms'[\cursor])]) \steps{\seq{\lbl}}
    (\lbl~\Tms[(\Group~\Tms'[\epsilon])~\cursor])
    }\\\\
    \irule{seq-create}{
    \lbl' \neq \lbl
    }{
    (\lbl'~\Tms[(\Group~\Tms'[\cursor])]) \steps{\seq{\lbl}}
    (\lbl'~\Tms[(\lbl~(\Group~\Tms'[\epsilon])~\cursor)])
    }\\\\
    \irule{seq-fail}{
    \lbl' \neq \Group\\
    (\lbl'~\Tms[\cursor]) \steps{\invalid} \Tm{}
    }{
    (\lbl'~\Tms[\cursor]) \steps{\seq{\lbl}} \Tm{}
    }\\\\
  \end{array}
\]

The action \term{\lbls} finishes the current group (if any) and
tries to move out of enclosing terms in the order of the labels in
\lbls, ignoring any non-matching labels. Note that this rule may
use the \rn{ctx} rule to find the right level for popping.

\[
  \begin{array}{c}
    \irule{term}{
    \Tm \steps{\trypop{\Group}} \Tm_0\\
    \forall~i\in[1..n]. \Tm_{i-1} \steps{\trypop{\lbl_i}} \Tm_i
%    \lbl_2(\Tms_2[\lbl_3(\Tms_3[\cursor])]) \steps{\trypop{\Group}} \Tm\\
%    \lbl_1(\Tms_1[\Tm]) \steps{\trypop{\lbl}} \Tm'
    }{
    \Tm \steps{\term{\lbl_1..\lbl_n}} \Tm_n
%    \lbl_1(\Tms_1[\lbl_2(\Tms_2[\lbl_3(\Tms_3[\cursor])])]) \steps{\term{\lbl}}
%    \Tm'
    }
  \end{array}
\]

Finally, the \done{} action finishes the final group (if any) and
closes the top-most term, which must have label \Top{} (As an aside,
note that we can't use \trypop{\Group} as \trypop{} assumes that
the cursor is at least at depth 2, which is not true when the
cursor a direct child of the top term). Note that the resulting
term is a term without a cursor.

\[
  \begin{array}{c}
    \irule{done}{}{
    (\Top~\Tms[\cursor]) \steps{\done} (\Top~\Tms[\epsilon])
    }
    \\\\
    \irule{done-group}{}{
    (\Top~\Tms[(\Group~\Tms'[\cursor])]) \steps{\done} (\Top~\Tms[(\Group~\Tms'[\epsilon])])
    }
  \end{array}
\]

If the cursor is \emph{not} a direct child of the top node (or in
a group that is a direct child of the top node), parsing has
terminated prematurely and we add \Unclosed{} terms along the path
to the top until we can finish the term:

\[
  \begin{array}{c}
    \irule{done-unclosed}{
    \lbl \neq \Group\\
    (\Top~\Tms[(\lbl~\Tms')]) \steps{\unclosed} \tm\\
    }{
    (\Top~\Tms[(\lbl~\Tms')]) \steps{\done} \tm
    }
    \\\\
    \irule{unclosed-top}{}{
    (\Top~\Tms[\cursor]) \steps{\unclosed} \Top(\Tms[(\Unclosed)])
    }
    \\\\
    \irule{unclosed-step}{
    \Tm \steps{\unclosed} \Tm'\\
    \Tm' \steps{\unclosed} \tm
    }{
    \Tm \steps{\unclosed} \tm
    }
    \\\\
    \irule{unclosed-add}{
    \lbl' \neq \Group
    }{
    (\lbl~\Tms[(\lbl'~\Tms'[\cursor])]) \steps{\unclosed}\\
    (\lbl~\Tms[(\lbl'~\Tms'[(\Unclosed)]) \cursor])
    }
    \\\\
    \irule{unclosed-group}{}{
    (\lbl~\Tms[(\lbl'~\Tms'[(\Group~\Tms''[\cursor])])]) \steps{\unclosed}\\
    (\lbl~\Tms[(\lbl'~\Tms'[(\Group~\Tms''[\epsilon]) ~ (\Unclosed)]) \cursor])
    }
  \end{array}
\]

\section{Pattern Matching}

\[
  \begin{array}{crll}
    \arrayheading{4}{Predicates}\\
      \phi & ::= & \fb{p}      & \text{followed by}         \\
           & ~|~ & \nfb{p}     & \text{not followed by}     \\
           & ~|~ & \pin{\lbl}  & \text{appears as child of} \\
           & ~|~ & \pstart{}   & \text{before all children} \\
           & ~|~ & \pend{}     & \text{after all children}  \\
    \\
    \arrayheading{4}{Patterns}\\
      p & ::= & \phi            & \text{predicate}                          \\
        & ~|~ & \lbl            & \text{a term with label $\lbl$}           \\
        & ~|~ & \any{}          & \text{any single term}                    \\
        & ~|~ & \por{p}{p}      & \text{choice}                             \\
        & ~|~ & \pseq{p}{p}     & \text{sequence}                           \\
        & ~|~ & \children{p}{p} & \text{children}                           \\
        & ~|~ & \pnot{p}        & \text{negation}                           \\
        & ~|~ & \maybe{p}       & \text{option}                             \\
        & ~|~ & \many{p}        & \text{repetition}                         \\
        & ~|~ & \bind{p}{x}     & \text{bind}                               \\
        & ~|~ & \paction{p}{f}  & \text{action}                             \\
  \end{array}
\]
%
During pattern matching we select some part of the a term based on
a pattern $p$. The dynamic pattern matching rules are presented in
Section~\ref{sec:match:dyn}. Among our patterns we distinguish
predicates $\phi$ which do not expand the current selection, but
give positional restrictions on which patterns may (or may not)
follow and inside which term we are currently matching.
%
Together with predicates, patterns are built from matching of
individual labels $\lbl$ and combining patterns through choice
$\por{p}{p}$, sequence $\pseq{p}{p}$, children $\children{p}{p}$,
negation $\pnot{p}$, option $\maybe{p}$ and repetition $\many{p}$.
%
During pattern matching, we bind subterms to names ($\bind{p}{x}$).
We can also supply a boolean function $f$ that must be true for
a selected part ($\paction{p}{f}$).

\subsection{Well-Formed Patterns}
\[
  \begin{array}{crll}
    \arrayheading{4}{Multiplicities}\\
    m      & ::= & 0 ~|~ 1 ~|~ \omega & \text{multiplicities}\\
    \Gamma & ::= & \Gamma, x : m ~|~ \epsilon & \text{multiplicity mapping}\\
  \end{array}
\]
%
In addition to pattern matching we define well-formedness rules
where each variable binding is associated with a
\emph{multiplicity} denoting the length of the sequence of terms
matched -- $0$, $1$ or an unknown number $\omega$. This helps rule
out some bad cases, such as taking the children of zero terms.

% Multiplicities of patterns are calculated as $\mu(p)$:

% \[
%   \begin{array}{rcl}
%     \mu(\phi)                & = & 0                         \\
%     \mu(\lbls)               & = & 1                         \\
%     \mu(!\lbls)              & = & 1                         \\
%     \mu(\any)                & = & 1                         \\
%     \mu(\por{p_1}{p_2})      & = & \mu(p_1) \oslash \mu(p_2) \\
%     \mu(\pseq{p_1}{p_2})     & = & \mu(p_1) \oplus \mu(p_2)  \\
%     \mu(\children{p_1}{p_2}) & = & \mu(p_1)                  \\
%     \mu(\pnot{p})            & = & \mu(p)                    \\
%     \mu(\maybe{p})           & = & \omega                    \\
%     \mu(\many{p})            & = & \omega                    \\
%     \mu(\bind{p}{x})         & = & \mu(p)                    \\
%     \mu(\paction{p}{f})      & = & \mu(p)                    \\
%   \end{array}
% \]

We define the following operations on multiplicities:

$
  m_1 \oplus m_2 =
  \begin{cases}
    0 & \text{if $m_1 = m_2 = 0$}\\
    1 & \text{if $m_1 = 0$ and $m_2 = 1$ or $m_1 = 1$ and $m_2 = 0$}\\
    \omega & \text{otherwise}\\
  \end{cases}
$

$
  m_1 \otimes m_2 =
  \begin{cases}
    0 & \text{if $m_1 = 0$ or $m_2 = 0$}\\
    m_1 & \text{if $m_2 = 1$}\\
    m_2 & \text{if $m_1 = 1$}\\
    \omega & \text{otherwise}\\
  \end{cases}
$

$
  m_1 \oslash m_2 =
  \begin{cases}
    0 & \text{if $m_1 = m_2 = 0$}\\
    1 & \text{if $m_1 = m_2 = 1$}\\
    \omega & \text{otherwise}\\
  \end{cases}
$

\noindent
We lift these operations to mappings in the expected way:

\[
  m \odot \Gamma =
  \begin{cases}
    (m \odot \Gamma'), x : (m \odot m') & \text{if } \Gamma = \Gamma', x : m'\\
    \epsilon & \text{otherwise}
  \end{cases}
\]
%
We also allow the point-wise combination of mappings, where we
provide a default multiplicity that we use for the mappings that
are only in one of the mappings.

% \[
%   \Gamma_1 \odot \Gamma_2 =
%   \begin{cases}
%     (\Gamma_1' \odot (\Gamma_2', \Gamma_2'')), x : (m_1 \odot m_2) &
%     \text{if } \Gamma_1 = \Gamma_1', x : m_1 \text{ and } \Gamma_2 = \Gamma_2', x : m_2, \Gamma_2''\\
%     \epsilon & \text{otherwise}
%   \end{cases}
% \]

\[
  \Gamma_1 \odot_m \Gamma_2 =
  \begin{cases}
    (\Gamma_1' \odot (\Gamma_2', \Gamma_2'')), x : (m_1 \odot m_2) &
    \text{if } \Gamma_1 = \Gamma_1', x : m_1 \text{ and } \Gamma_2 = \Gamma_2', x : m_2, \Gamma_2''\\
    (\Gamma_1' \odot \Gamma_2), x : (m \odot m_1) &
    \text{if } \Gamma_1 = \Gamma_1', x : m_1 \text{ and } x \notin \mathbf{dom}(\Gamma_2)\\
    m \odot \Gamma_2 & \text{otherwise}
  \end{cases}
\]
%
The well-formedness relation takes the shape \wfp{\Gamma}{p}{m},
meaning ``$p$ has multiplicity $m$ with the bindings in
$\Gamma$''. \TODO{It might be more intuitive to pick a syntax
  where it is clear that $\Gamma$ is an output. }

All the predicates are well-formed with multiplicity $0$ if their
nested patterns are well-formed. Any bindings in the nested
patterns are discarded.
%
The atomic single term patterns have multiplicity $1$ and
trivially have no bindings.

\[
  \begin{array}{c}
    \irule{wf-followed-by}{
    \wfp{\Gamma}{p}{m}
    }{
    \wfp{\epsilon}{\fb{p}}{0}
    }
    \quad
    \irule{wf-not-followed-by}{
    \wfp{\Gamma}{p}{m}
    }{
    \wfp{\epsilon}{\nfb{p}}{0}
    }
    \quad
    \irule{wf-in}{
    }{
    \wfp{\epsilon}{\pin{\lbl}}{0}
    }
    \\\\
    \irule{wf-start}{
    }{
    \wfp{\epsilon}{\pstart}{0}
    }
    \quad
    \irule{wf-end}{
    }{
    \wfp{\epsilon}{\pend}{0}
    }
    \\\\
    \irule{wf-label}{
    }{
    \wfp{\epsilon}{\lbl}{1}
    }
    \quad
    \irule{wf-any}{
    }{
    \wfp{\epsilon}{\any}{1}
    }
  \end{array}
\]
%
For choice, the multiplicity of an overlapping binding is known
only if it is the same ($0$ or $1$) in both branches. Similarly,
the resulting multiplicity is $\omega$ unless both branches have
the same multiplicity. Bindings that appear in only one of the
branches get an unknown multiplicity since we don't know which
branch has been chosen (this is handled by the $\oslash_\omega$
operation).

\[
  \begin{array}{c}
    \irule{wf-choice}{
    \wfp{\Gamma_1}{p_1}{m_1}
    \quad
    \wfp{\Gamma_2}{p_2}{m_2}
%    \mathbf{dom}(\Gamma_1) = \mathbf{dom}(\Gamma_2)
    }{
    \wfp{\Gamma_1 \oslash_\omega \Gamma_2}{\por{p_1}{p_2}}{m_1\oslash m_2}
    }
  \end{array}
\]
%
The sequences and children patterns produce the union of their
bindings and disallow overlapping bindings. The root of the
children pattern must have multiplicity $1$.
%
Optional and repeating patterns give bindings in nested patterns
the multiplicity $\omega$, since we don't know if they consume
anything.

\[
  \begin{array}{c}
    \irule{wf-seq}{
    \wfp{\Gamma_1}{p_1}{m_1}\quad
    \wfp{\Gamma_2}{p_2}{m_2}\\
    \mathbf{dom}(\Gamma_1) \cap \mathbf{dom}(\Gamma_2) = \emptyset
    }{
    \wfp{\Gamma_1, \Gamma_2}{\pseq{p_1}{p_2}}{m_1\oplus m_2}
    }
    \quad
    \irule{wf-children}{
    \wfp{\Gamma_1}{p_1}{1}
    \quad
    \wfp{\Gamma_2}{p_2}{m}\\
    \mathbf{dom}(\Gamma_1) \cap \mathbf{dom}(\Gamma_2) = \emptyset
    }{
    \wfp{\Gamma_1, \Gamma_2}{\children{p_1}{p_2}}{1}
    }
    \\\\
    \irule{wf-option}{
    \wfp{\Gamma}{p}{m}
    }{
    \wfp{\omega \oplus \Gamma}{\maybe{p}}{\omega}
    }
    \quad
    \irule{wf-many}{
    \wfp{\Gamma}{p}{m}
    }{
    \wfp{\omega \oplus \Gamma}{\many{p}}{\omega}
    }
  \end{array}
\]
%
Negation \pnot{p} means ``consume one thing that does not match
$p$'' and so it is only meaningful for patterns with multiplicity
$1$ (for negation that does not consume we have \nfb{p}). Nested
bindings are discarded.

\[
  \begin{array}{c}
    \irule{wf-not}{
    \wfp{\Gamma}{p}{1}
    }{
    \wfp{\epsilon}{\pnot{p}}{1}
    }
  \end{array}
\]
%
A bound variable must not be repeated in the same pattern and gets
the multiplicity of the underlying pattern. Actions are ignored.
\[
  \begin{array}{c}
    \irule{wf-bind}{
    \wfp{\Gamma}{p}{m}
    \quad
    x \notin{\mathbf{dom}(\Gamma)}
    }{
    \wfp{\Gamma, x : m}{\bind{p}{x}}{m}
    }
    \quad
    \irule{wf-action}{
    \wfp{\Gamma}{p}{m}
    }{
    \wfp{\Gamma}{\paction{p}{f}}{m}
    }
  \end{array}
\]


\subsubsection{Aside: Matching Children of Several Terms}

A different version of the children pattern allows the root to
have any multiplicity, and then multiplies the bindings in the
child pattern by that multiplicity. Note that this requires the
dynamic matching rule to fail when the root matches zero terms.

\[
  \begin{array}{c}
    \irule{wf-children-alt}{
    \wfp{\Gamma_1}{p_1}{m_1}
    \quad
    \wfp{\Gamma_2}{p_2}{m_2}\\
    \mathbf{dom}(\Gamma_1) \cap \mathbf{dom}(\Gamma_2) = \emptyset
    }{
    \wfp{\Gamma_1, m_1 \otimes \Gamma_2}{\children{p_1}{p_2}}{m_1}
    }
  \end{array}
\]
%
What this gives us is the ability to concatenate the children of
several terms. For example, we can have ``get the first children
of a $\mathit{foo}$ followed by a $\mathit{bar}$'':

\[
  \wfp{x : \omega}{\children{(\pseq{\mathit{foo}}{\mathit{bar}})}{(\bind{\any}{x})}}{\omega}
\]
%
Note that the static rule for \many{p} already allows for the
semantics that concatenates bindings under $p$.

\subsection{Dynamic Semantics}
\label{sec:match:dyn}

\[
  \begin{array}{rcl}
    \arrayheading{3}{Terms with a sequence being matched}\\
    \Tmc & ::= & (\lbl~\Tmcs) ~|~ (\lbl~\tms~\select{\tms}~\tms)\\
    \Tmcs & ::= & \Tmc ~ \tms ~|~ \tm ~ \Tmcs\\
    \\
    \arrayheading{3}{Contexts (shallow)}\\
    \Tmc[\bullet] & ::= & (\lbl~\Tmcs[\bullet])\\
    \Tmcs[\bullet] & ::= & \bullet ~ \tms ~|~ \tm ~ \Tmcs[\bullet]\\
    \\
    \arrayheading{3}{Bindings}\\
    x         & \in & \mathcal{X}\\
    \bindings & \in & \mathcal{X} \mapsto \tms\\
    % \\
    % \multicolumn{3}{l}{
    % \begin{array}{crll}
    % \arrayheading{4}{Patterns}\\
    %   \phi & ::= & \fb{p}      & \text{followed by}         \\
    %        & ~|~ & \pin{\lbl}  & \text{appears as child of} \\
    %        & ~|~ & \pstart{}   & \text{before all children} \\
    %        & ~|~ & \pend{}     & \text{after all children}  \\
    %        & ~|~ & \pnot{\phi} & \text{negation}            \\
    %   \\
    %   p & ::= & \phi            & \text{predicate}                          \\
    %     & ~|~ & \lbls           & \text{a term with label in $\lbls$}       \\
    %     & ~|~ & !\lbls          & \text{a term with a label not in $\lbls$} \\
    %     & ~|~ & \any{}          & \text{any single term}                    \\
    %     & ~|~ & \por{p}{p}      & \text{choice}                             \\
    %     & ~|~ & \pseq{p}{p}     & \text{sequence}                           \\
    %     & ~|~ & \children{p}{p} & \text{children}                           \\
    %     & ~|~ & \maybe{p}       & \text{option}                             \\
    %     & ~|~ & \many{p}        & \text{repetition}                         \\
    %     & ~|~ & \bind{p}{x}     & \text{bind}                               \\
    %     & ~|~ & \paction{p}{f}  & \text{action}                             \\
    % \end{array}
    % }
  \end{array}
\]
%
During matching we are selecting a sequence of sibling terms. A
term \Tmc{} is a term where one such sequence has been selected.
We represent the subterm whose children are being matched as
$(\lbl~\tms_{pre}~\select{\tms}~\tms_{post})$: a $\lbl$ term
where some subsequence $\tms$ of its children has been selected,
$\tms_{pre}$ being the terms before the match and $\tms_{post}$
the terms after the match. Matching commences by looking at terms
in $\tms_{post}$ and moving them into the matched sequence, or
equivalently, advancing the cursor $\mend$. Note that the coloring
has no semantic meaning.

The result of matching, apart from moving the cursor $\mend$, is a
set of bindings $\bindings$ which maps variables to sequences of
terms.
%
%
% If the same variable name is used more than once, the later
% binding is preferred. We write $\extend{\bindings_1}{\bindings_2}$
% to mean the union of $\bindings_1$ and $\bindings_2$ where
% bindings from $\bindings_2$ override overlapping bindings from
% $\bindings_1$:
%
% \[
%     \extend{\bindings_1}{\bindings_2} = \bindings_2\cup \{x\mapsto \bindings_1(x) ~|~ x \in (\mathbf{dom}(\bindings_1)\setminus\mathbf{dom}(\bindings_2))\}
% \]
%
The pattern matching rule takes the shape
$\matches{p}{\Tmc_1}{\Tmc_2}{\bindings}$, where we start from
$\Tmc_1$ and match $p$, (possibly) extending the selection
resulting in $\Tmc_2$ and the bindings $\bindings$.

Throughout, we use $\lbl_\pi$ as the label of the parent of the
nodes we are matching on.
%
Patterns $\bind{p}{x}$ introduce a binding and remembers the terms
that were matched in the resulting binding set:

\[
  \begin{array}{c}
    \irule{match-bind}{
    \xmatches{p}{(\lbl_\pi~\tms_{pre}~\select{\tms}~\tms_{post})}
                {(\lbl_\pi~\tms_{pre}~\select{\tms~\tms'}~\tms'_{post})}{\bindings}
    }{
    \xmatches{\bind{p}{x}}
    {(\lbl_\pi~\tms_{pre}~\select{\tms}~\tms_{post})}
    {(\lbl_\pi~\tms_{pre}~\select{\tms~\tms'}~\tms'_{post})}{\extend{\bindings}{\{x\mapsto \tms'\}}}
    }
  \end{array}
\]
%
\pstart{} and \pend{} match the very start and the very end
respectively of the full sequence of children:

\[
  \begin{array}{c}
    \irule{match-start}{}{
    \matches{\pstart}
    {(\lbl_\pi~\mstart\mend~\tms_{post})}
    {(\lbl_\pi~\mstart\mend~\tms_{post})}{\nobindings}
    }
    \\\\
    \irule{match-end}{}{
    \xmatches{\pend}
    {(\lbl_\pi~\tms_{pre}~\select{\tms})}
    {(\lbl_\pi~\tms_{pre}~\select{\tms})}{\nobindings}
    }
  \end{array}
\]
%
$\pin{\lbl}$ succeeds if we are matching directly inside a $\lbl$
term:

\[
  \begin{array}{c}
    \irule{match-in}{}{
    \xmatches{\pin{\lbl_\pi}}
    {(\lbl_\pi~\tms_{pre}~\select{\tms}~\tms_{post})}
    {(\lbl_\pi~\tms_{pre}~\select{\tms}~\tms_{post})}{\nobindings}
    }
  \end{array}
\]
%
The lookahead patterns $\fb{p}$ and $\nfb{p}$ tries the pattern
$p$, but does not advance the cursor nor remember bindings.

\[
  \begin{array}{c}
    \irule{match-followed-by}{
    \matches{p}{(\lbl_\pi~\tms_{pre}~\select{\tms}~\tms_{post})}{\Tmc}{\bindings}
    }{
    \xmatches{\fb{p}}
    {(\lbl_\pi~\tms_{pre}~\select{\tms}~\tms_{post})}
    {(\lbl_\pi~\tms_{pre}~\select{\tms}~\tms_{post})}{\nobindings}
    }
    \\\\
    \irule{match-not-followed-by}{
    \lnot\left(\matches{p}{(\lbl_\pi~\tms_{pre}~\select{\tms}~\tms_{post})}{\Tmc}{\bindings}\right)
    }{
    \xmatches{\nfb{p}}
    {(\lbl_\pi~\tms_{pre}~\select{\tms}~\tms_{post})}
    {(\lbl_\pi~\tms_{pre}~\select{\tms}~\tms_{post})}{\nobindings}
    }
  \end{array}
\]
%
Matching on labels $\lbl$ succeeds if the next label matches.
Wildcards $\any$ always succeeds as long as there is a next term.

\[
  \begin{array}{c}
    \irule{match-label}{
    }{
    \xmatches{\lbl}
    {(\lbl_\pi~\tms_{pre}~\select{\tms}~(\lbl~\tms')~\tms_{post})}
    {(\lbl_\pi~\tms_{pre}~\select{\tms~(\lbl~\tms')}~\tms_{post})}{\nobindings}
    }
    \\\\
    \irule{match-any}{}{
    \xmatches{\any}
    {(\lbl_\pi~\tms_{pre}~\select{\tms}~(\lbl~\tms')~\tms_{post})}
    {(\lbl_\pi~\tms_{pre}~\select{\tms~(\lbl~\tms')}~\tms_{post})}{\nobindings}
    }
  \end{array}
\]
%
Matching choice $\por{p_1}{p_2}$ works as expected, but is
\emph{ordered}, meaning the first pattern is preferred if both
patterns match.

\[
  \begin{array}{c}
    \irule{match-choice-l}{
    \matches{p_1}{(\lbl_\pi~\tms_{pre}~\select{\tms}~\tms_{post})}{\Tmc}{\bindings}
    }{
    \matches{\por{p_1}{p_2}}
    {(\lbl_\pi~\tms_{pre}~\select{\tms}~\tms_{post})}
    {\Tmc}{\bindings}
    }
    \\\\
    \irule{match-choice-r}{
    \lnot\left(\matches{p_1}{(\lbl_\pi~\tms_{pre}~\select{\tms}~\tms_{post})}{\Tmc_1}{\bindings_1}\right)\\
    \matches{p_2}{(\lbl_\pi~\tms_{pre}~\select{\tms}~\tms_{post})}{\Tmc_2}{\bindings_2}
    }{
    \matches{\por{p_1}{p_2}}
    {(\lbl_\pi~\tms_{pre}~\select{\tms}~\tms_{post})}
    {\Tmc_2}{\bindings_2}
    }
  \end{array}
\]
%
Matching a sequence $\pseq{p_1}{p_2}$ concatenates the results of the match.

\[
  \begin{array}{c}
    \irule{match-sequence}{
    \matches{p_1}{(\lbl_\pi~\tms_{pre}~\select{\tms}~\tms_{post})}{\Tmc_1}{\bindings_1}\\
    \matches{p_2}{\Tmc_1}{\Tmc_2}{\bindings_2}\\
    }{
    \matches{\pseq{p_1}{p_2}}
    {(\lbl_\pi~\tms_{pre}~\select{\tms}~\tms_{post})}
    {\Tmc_2}{\extend{\bindings_1}{\bindings_2}}
    }
  \end{array}
\]
%
Matching children $\children{p_1}{p_2}$ first uses $p_1$ to match
a single node, and then further requires that $p_2$ matches its
children (we don't care about \emph{which} terms are matched
here). We transfer the bindings from the inner match to the final
result.

\[
  \begin{array}{c}
    \irule{match-children}{
    \xmatches{p_1}{(\lbl_\pi~\tms_{pre}~\select{\tms}~(\lbl~\tms_1)~\tms_{post})}
                  {(\lbl_\pi~\tms_{pre}~\select{\tms~(\lbl~\tms_1)}~\tms_{post})}{\bindings_1}\\
    \matches{p_2}{(\lbl~\mstart\mend~\tms_1)}{\Tmc}{\bindings_2}
    }{
    \xmatches{\children{p_1}{p_2}}
    {(\lbl_\pi~\tms_{pre}~\select{\tms}~(\lbl~\tms_1)~\tms_{post})}
    {(\lbl_\pi~\tms_{pre}~\select{\tms~(\lbl~\tms_1)}~\tms_{post})}
    {\extend{\bindings_1}{\bindings_2}}
    }
  \end{array}
\]
%
Negation $\pnot{p}$ matches if there is a term to consume and the
predicate $p$ does not match. It consumes one term but never
remembers bindings.

\[
  \begin{array}{c}
    \irule{match-not}{
    \lnot\left(\matches{p}{(\lbl_\pi~\tms_{pre}~\select{\tms}~(\lbl~\tms')~\tms_{post})}{\Tmc}{\bindings}\right)
    }{
    \xmatches{\pnot{p}}
    {(\lbl_\pi~\tms_{pre}~\select{\tms}~(\lbl~\tms')~\tms_{post})}
    {(\lbl_\pi~\tms_{pre}~\select{\tms~(\lbl~\tms')}~\tms_{post})}{\nobindings}
    }
  \end{array}
\]
%
Optional matches $\maybe{p}$ always succeed, but matches $p$ if
possible.

\[
  \begin{array}{c}
    \irule{match-option-yes}{
    \matches{p}{(\lbl_\pi~\tms_{pre}~\select{\tms}~\tms_{post})}{\Tmc}{\bindings}
    }{
    \matches{\maybe{p}}
    {(\lbl_\pi~\tms_{pre}~\select{\tms}~\tms_{post})}
    {\Tmc}{\bindings}
    }
    \\
    \\
    \irule{match-option-no}{
    \lnot\left(\matches{p}{(\lbl_\pi~\tms_{pre}~\select{\tms}~\tms_{post})}{\Tmc}{\bindings}\right)
    }{
    \xmatches{\maybe{p}}
    {(\lbl_\pi~\tms_{pre}~\select{\tms}~\tms_{post})}
    {(\lbl_\pi~\tms_{pre}~\select{\tms}~\tms_{post})}{\nobindings}
    }
  \end{array}
\]
%
Repetition of a pattern $\many{p}$ will greedily match $p$ as many
times as possible, but requires that progress is made for each
match.

\[
  \begin{array}{c}
    \irule{match-many-more}{
    \xmatches{p}{(\lbl_\pi~\tms_{pre}~\select{\tms}~\tms_{post})}
                {(\lbl_\pi~\tms_{pre}~\select{\tms~\tms'}~\tms'_{post})}{\bindings}
    \quad\tms' \neq \epsilon\\
    \matches{\many{p}}{(\lbl_\pi~\tms_{pre}~\select{\tms~\tms'}~\tms'_{post})}{\Tmc_2}{\bindings_2}
    }{
    \matches{\many{p}}
    {(\lbl_\pi~\tms_{pre}~\select{\tms}~\tms_{post})}
    {\Tmc_2}{\extend{\bindings_1}{\bindings_2}}
    }
    \\\\
    \irule{match-many-done}{
    \lnot\left(\matches{p}{(\lbl_\pi~\tms_{pre}~\select{\tms}~\tms_{post})}{\Tmc}{\bindings}\right)
    }{
    \xmatches{\many{p}}
    {(\lbl_\pi~\tms_{pre}~\select{\tms}~\tms_{post})}
    {(\lbl_\pi~\tms_{pre}~\select{\tms}~\tms_{post})}{\nobindings}
    }
  \end{array}
\]
%
An action pattern $\paction{p}{f}$ comes equipped with a function
$f : \tms \mapsto \mathbf{bool}$ which must return $\mathbf{true}$
for the matched pattern.

\[
  \begin{array}{c}
    \irule{match-action}{
    \xmatches{p}{(\lbl_\pi~\tms_{pre}~\select{\tms}~\tms_{post})}
                {(\lbl_\pi~\tms_{pre}~\select{\tms~\tms'}~\tms'_{post})}{\bindings}\\
    f(\tms') = \mathbf{true}
    }{
    \xmatches{\paction{p}{f}}
    {(\lbl_\pi~\tms_{pre}~\select{\tms}~\tms_{post})}
    {(\lbl_\pi~\tms_{pre}~\select{\tms~\tms'}~\tms'_{post})}{\bindings}
    }
  \end{array}
\]
%
As with parsing, we use contexts to ``zoom in'' until we can apply
a matching rule.

\[
  \begin{array}{c}
    \irule{match-ctx}{
    \matches{p}{\Tmc_1}{\Tmc_2}{\bindings}
    }{
    \matches{p}{\Tmc[\Tmc_1]}{\Tmc[\Tmc_2]}{\bindings}
    }
  \end{array}
\]

\subsubsection{Aside: Matching Children of Several Terms}

We can allow an alternative semantics for children and repetition,
in which repeated bindings are concatenated. Note that we require
the root of children to match at least one term.

\[
  \begin{array}{c}
    \irule{match-many-more-alt}{
    \xmatches{p}{(\lbl_\pi~\tms_{pre}~\select{\tms}~\tms_{post})}
                {(\lbl_\pi~\tms_{pre}~\select{\tms~\tms'}~\tms'_{post})}{\bindings}
    \quad\tms' \neq \epsilon\\
    \matches{\many{p}}{(\lbl_\pi~\tms_{pre}~\select{\tms~\tms'}~\tms'_{post})}{\Tmc_2}{\bindings_2}
    }{
    \matches{\many{p}}
    {(\lbl_\pi~\tms_{pre}~\select{\tms}~\tms_{post})}
    {\Tmc_2}{\bindings_1\concat\bindings_2}
    }
    \\\\
    \irule{match-many-done-alt}{
    \lnot\left(\matches{p}{(\lbl_\pi~\tms_{pre}~\select{\tms}~\tms_{post})}{\Tmc}{\bindings}\right)
    }{
    \xmatches{\many{p}}
    {(\lbl_\pi~\tms_{pre}~\select{\tms}~\tms_{post})}
    {(\lbl_\pi~\tms_{pre}~\select{\tms}~\tms_{post})}{\nobindings}
    }
    \\\\
    \irule{match-children-alt}{
    \xmatches{p_1}{(\lbl_\pi~\tms_{pre}~\select{\tms}~\tms_{post})}
                  {(\lbl_\pi~\tms_{pre}~\select{\tms~\tms'}~\tms'_{post})}{\bindings_0}\\
    \tms' = (\lbl_1~\tms_1) \ldots (\lbl_n~\tms_n)\quad n > 0\\
    \forall i \in [1..n].~\matches{p_2}{(\lbl_i~\mstart\mend~\tms_i)}{\Tmc_i}{\bindings_i}
    }{
    \xmatches{\children{p_1}{p_2}}
    {(\lbl_\pi~\tms_{pre}~\select{\tms}~\tms_{post})}
    {(\lbl_\pi~\tms_{pre}~\select{\tms~\tms'}~\tms'_{post})}
    {\extend{\bindings_0}{(\bindings_1\concat\ldots\concat\bindings_n)}}
    }
  \end{array}
\]
%
Concatenation of bindings is defined as the concatenation of the
results of their overlapping bindings.

\[
  \begin{array}{l}
    \bindings_1 \concat \bindings_2 =
      \{x \mapsto (\tms_1 \concat \tms_2) ~|~
        \bindings_1(x) = \tms_1 ~\land~
        \bindings'_2(x) = \tms_2
      \}
    \\\\\quad
    \text{ where } \bindings'_2(x) =
    \begin{cases}
      \bindings_2(x) & \text{if } x \in \mathbf{dom}(\bindings_2)\\
      \epsilon & \text{otherwise}
    \end{cases}
  \end{array}
\]

\subsection{Soundness}

We say that a multiplicity $m$ describes a sequence of terms
$\tms$ if the length of $\tms$ is the same as $m$ (where $\omega$
is any length).

\[
  \begin{array}{c}
    \irule{mult-0}{

    }{
    0 \vdash \epsilon
    }
    \quad
    \irule{mult-1}{

    }{
    1 \vdash (\lbl~\tms)
    }
    \quad
    \irule{mult-$\omega$}{

    }{
    \omega \vdash \tms
    }
  \end{array}
\]
%
A set of bindings $\bindings$ is well-formed under some $\Gamma$
if the value of every binding is described by the corresponding
mapping in $\Gamma$:

\[
  \begin{array}{c}
    \irule{wf-bindings-cons}{
    \Gamma \vdash \bindings\quad
    m \vdash \tms
    }{
    \Gamma, x : m \vdash \bindings \cup \{x \mapsto \tms\}
    }
    \quad
    \irule{wf-bindings-empty}{
    }{
    \epsilon \vdash \nobindings
    }
  \end{array}
\]
%
We define soundness of pattern matching to mean that a matching
pattern, well-formed under $\Gamma$ with multiplicity $m$ consumes
a sequence of terms whose length is described by $m$. In addition,
the bindings produced are well-formed under $\Gamma$.

\[
  \begin{array}{l}
    \begin{array}{l}
    \wfp{\Gamma}{p}{m}~~~\land\\
      ~
    \end{array}
    \xmatches{p}{(\lbl_\pi~\tms_{pre}~\select{\tms}~\tms_{post})}
                {(\lbl_\pi~\tms_{pre}~\select{\tms~\tms'}~\tms'_{post})}{\bindings}
    \\
    \quad\implies\\
    \qquad m \vdash \tms' ~\land~ \Gamma \vdash \bindings
  \end{array}
\]

\subsection{Alternative with Simpler Negation}

\[
  \begin{array}{crll}
    \arrayheading{4}{Predicates}\\
      \phi & ::= & \fb{p}      & \text{followed by}         \\
           & ~|~ & \pin{\lbl}  & \text{appears as child of} \\
           & ~|~ & \pstart{}   & \text{before all children} \\
           & ~|~ & \pend{}     & \text{after all children}  \\
           & ~|~ & \pnot{\phi} & \text{negation}            \\
    \\
    \arrayheading{4}{Patterns}\\
      p & ::= & \phi            & \text{predicate}                          \\
        & ~|~ & \lbls           & \text{a term with a label in $\lbls$}     \\
        & ~|~ & !\lbls          & \text{a term with a label \emph{not} in $\lbls$}     \\
        & ~|~ & \any{}          & \text{any single term}                    \\
        & ~|~ & \por{p}{p}      & \text{choice}                             \\
        & ~|~ & \pseq{p}{p}     & \text{sequence}                           \\
        & ~|~ & \children{p}{p} & \text{children}                           \\
        & ~|~ & \maybe{p}       & \text{option}                             \\
        & ~|~ & \many{p}        & \text{repetition}                         \\
        & ~|~ & \bind{p}{x}     & \text{bind}                               \\
        & ~|~ & \paction{p}{f}  & \text{action}                             \\
    \\
    \arrayheading{4}{Multiplicities}\\
    \Gamma & ::= & \Gamma, x : m ~|~ \epsilon & \text{multiplicity mapping}\\
    m      & ::= & 0 ~|~ 1 ~|~ \omega & \text{multiplicities}
  \end{array}
\]
%
In this version, negation only exists for predicates (meaning
there is only one matching rule for negation). The case of
matching a single term whose label is \emph{not} among a set of
labels is done by a special term $!\lbls$.

This formulation requires a workaround for the pattern\\
$\many{(\pnot{(\por{(\children{\mathit{foo}}{p_1})}{(\children{\mathit{bar}}{p_2})})})}$
\subsection{Thoughts}

\begin{itemize}
\item We should really have choice (and conjunction?) at the
  top-level, to be able to allow, e.g.,
  $\por{(\pseq{\pin{\lbl}}{\mathit{foo}})}{bar}$. We could allow
  negation of choice if we had conjunction at the top-level, but
  we do not want general negation.
\item We could have patterns $\mathit{lbls}$ and $!\mathit{lbls}$
  for disjunctive positive and conjunctive negative single term
  patterns respectively.
\item We could use the type system to say that you can get the
  children of anything as long as it has multiplicity $1$.
\item Should we allow overriding bindings? We could allow it in
  the matching semantics if we want well-formedness to be opt-in.
\item The \none{} pattern isn't quite right. We would like to have
  the property that if a pattern $p$ does not match, then the
  negation of the pattern \pnot{p} does match (and vice versa).
  The pattern \any{} does not match on the empty sequence, but
  neither does its negation \none{} (since it never matches).
  Similarly, \none{} does not match on the empty sequence, but
  neither does its negation \any{} (since it requires at least one
  term).
  \begin{itemize}
  \item Akhshualy, if you have an empty sequence, all $s$ patterns
    have the same issue as above! So maybe \none{} is back on the
    table.
  \end{itemize}
\item \any{} is equivalent to \por{\pnot{a}}{\pnot{b}} for
  disjoint $a$ and $b$.
\item Does it make sense to bind within $\fb{p}$?
\end{itemize}
%
Annoying things:

\begin{itemize}
\item We cannot define $\lnot(\lnot p) = p$, since that would
  require negation of general patterns, which does not make sense.
\item $|\lnot p| = |p|$ except for $\any$, where $|\lnot\any| = 0$
  \TODO{Actually, we could think of \any{} as ``match a single
    term with any label'', and then \pnot{\any{}} would be a
    pattern that never succeeds}
\end{itemize}
%
Possibly reasonable things:

\begin{itemize}
\item $\lnot \pin{\lbl}$
\item $\lnot (\pseq{p_1}{p_2})$, but that could also be
  $\pseq{\nfb{\pseq{p_1}{p_2}}}{\pseq{\any\times|p_1|}{\any\times|p_2|}}$
\end{itemize}
%
It does not make sense to negate patterns which always succeed,
i.e., option or repetition.

Things that appear in the wild
\begin{itemize}
\item
\begin{verbatim}
(~T(Brace) *
  (((T(Symbol) / T(Dot)) * T(Brace)) /
   (!(T(Brace) / T(TripleColon))))++)
\end{verbatim}
\item \texttt{((In(Top) * T(File)[Class]) / T(Directory)[Class])}
\item \texttt{(!(T(Brace) / T(TripleColon)))}
\item \texttt{(In(Top) / In(ClassBody) / In(Block))}
\item
\begin{verbatim}
(T(Plus) / T(Minus) / T(Mult) / T(Div)) << T(Expression)
\end{verbatim}
\end{itemize}

\section{Term Rewriting}

After we have selected some part of a term via pattern matching,
term rewriting replaces the selected part with a sequence of
terms, possibly built using variables which are replaced by their
corresponding bindings found during pattern matching. In other
words, term rewriting is a function from $\Tmc$ to $\tm$.

We will need:

\begin{itemize}
\item A definition of symbolic terms $\Tmx$ which may contain variables
\item Well-formed symbolic terms $\Gamma \vdash \Tmx$
\item A relation that takes a $\Tmc$, a $\Tmx$ and a $\bindings$
  to $\tm$ (possibly to another $\Tmc$, where the cursor is right
  before or right after the previous selection)
\item A relation that tries a selection of patterns with
  associated symbolic terms and then \RED{advances the cursor}.
\end{itemize}

\section{Pass Specifications}

Well-formedness rules

\section*{TODO}

\begin{itemize}
\item Top-down vs. Bottom-up. Also Breadth-first vs. Depth-first!
  \begin{itemize}
  \item If we go breadth first, once we have finished processing
    one layer of terms during rewriting, each sibling in the next
    layer can be processed in parallel!
  \end{itemize}
\item Regex matching (requires carrying data)
\item Well-formedness
\item Symbol tables
\item Location information, error reporting
\end{itemize}

\section*{Quiz}

\begin{verbatim}
((T(Foo) * T(Bar)) << Any[Id]) >>
  [](Match& _) { return _(Id); }

(foo a) (bar b) --> a
\end{verbatim}

\begin{verbatim}
(In(Foo) << Any[Id]) >>
  [](Match& _) { return _(Id); }

(foo a) (bar b) --> Segmentation fault
\end{verbatim}

\begin{verbatim}
((!In(Bar)) * T(Baz)) >>
  [](Match& _) { return NodeDef::create(Fr0b); }

(foo baz) --> fr0b
\end{verbatim}

\end{document}
