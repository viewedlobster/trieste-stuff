\documentclass{article}

\usepackage{amsmath, amssymb}
\usepackage[usenames,dvipsnames]{xcolor}

\newcommand{\RED}[1]{\textcolor{red}{#1}}
\newcommand{\TODO}[1]{\RED{[TODO: #1]}}

\newcommand{\rulename}{\textsc}
\newcommand{\rn}{\rulename}

\newcommand{\irule}[3]{\begin{array}{l}{~\small\mbox{(\rulename{#1})}}\\\;\frac{\begin{array}{c}#2\end{array}}{\begin{array}{l}#3\end{array}}\end{array}}
%\newcommand{\irule}[3]{\frac{\begin{array}{c}#2\end{array}}{\begin{array}{l}#3\end{array}}{~\small\mbox{(\rulename{#1})}}}

\newcommand{\labelFont}{\texttt}
\newcommand{\cursorColor}{LimeGreen}

\newcommand{\lbl}{\ensuremath{\mathit{lbl}}}
\newcommand{\lbls}{\ensuremath{\mathit{lbls}}}
\newcommand{\Top}{\ensuremath{\labelFont{Top}}}
\newcommand{\Group}{\ensuremath{\labelFont{Group}}}
\newcommand{\Invalid}{\ensuremath{\labelFont{Invalid}}}
\newcommand{\Unclosed}{\ensuremath{\labelFont{Unclosed}}}

\newcommand{\tm}{\ensuremath{\mathtt{tm}}}
\newcommand{\tms}{\ensuremath{\mathtt{tms}}}

\newcommand{\Tm}{\ensuremath{\check{\tm}}}
\newcommand{\Tms}{\ensuremath{\check{\tms}}}

\newcommand{\Tmc}{\ensuremath{\overset{ \textcolor{\cursorColor}{\bowtie}}{\tm}}}
\newcommand{\Tmcb}{\ensuremath{\overset{{\bowtie}}{\tm}}}
\newcommand{\Tmcs}{\ensuremath{\overset{\textcolor{\cursorColor}{\bowtie}}{\tms}}}

%% Actions
\newcommand{\action}{\ensuremath{\alpha}}
\newcommand{\add}[1]{\ensuremath{\texttt{add}~#1}}
\newcommand{\push}[1]{\ensuremath{\texttt{push}~#1}}
\newcommand{\pop}[1]{\ensuremath{\texttt{pop}~#1}}
\newcommand{\trypop}[1]{\ensuremath{\texttt{trypop}~#1}}
\newcommand{\seq}[1]{\ensuremath{\texttt{seq}~#1}}
\newcommand{\term}[1]{\ensuremath{\texttt{term}~#1}}
\newcommand{\invalid}{\ensuremath{\texttt{invalid}}}
\newcommand{\unclosed}{\ensuremath{\texttt{unclosed}}}
\newcommand{\done}{\ensuremath{\texttt{done}}}

%% Cursors and matching
\newcommand{\cursor}{\ensuremath{\downarrow}}
\newcommand{\mstart}{\ensuremath{\textcolor{\cursorColor}{\rhd}}}
\newcommand{\mend}{\ensuremath{\textcolor{\cursorColor}{\lhd}}}

\newcommand{\bindings}{\ensuremath{\mathcal{M}}}
\newcommand{\nobindings}{\ensuremath{\emptyset}}
\newcommand{\extend}[2]{\ensuremath{#1\overset{\rightarrow}{\cup}#2}}
\newcommand{\concat}{\ensuremath{\mathop{+\!\!+}}}

\newcommand{\select}[1]{\mstart\colorbox{\cursorColor}{$#1$}\mend}

\newcommand{\steps}[1]{\ensuremath{\xrightarrow{#1}}}
\newcommand{\matches}[4]{\ensuremath{#1 \vdash #2 \Rightarrow #3 ~|~ #4}}
\newcommand{\xmatches}[4]{\ensuremath{
    \begin{array}{r@{\hspace{4pt}}c@{\hspace{4pt}}l}%
      #1 & \vdash & #2 \Rightarrow\\
         &        & #3 ~|~ #4
    \end{array}}}

\newcommand{\matchesm}[5]{\ensuremath{#1 \vdash #2 : #3 \Rightarrow #4 ~|~ #5}}
\newcommand{\xmatchesm}[5]{\ensuremath{
    \begin{array}{r@{\hspace{4pt}}c@{\hspace{2pt}}l}
      #1 & \vdash & #2 : #3\Rightarrow\\
         &        & #4 ~|~ #5
    \end{array}}}

\newcommand{\wfp}[2]{\ensuremath{#1 \vdash #2}}

%% Patterns
\newcommand{\pseq}[2]{\ensuremath{#1 \cdot #2}}
\newcommand{\por}[2]{\ensuremath{#1/#2}}
\newcommand{\pand}[2]{\ensuremath{#1\&#2}}
\newcommand{\children}[2]{\ensuremath{#1} \Downarrow #2}
\newcommand{\pnot}[1]{\ensuremath{\lnot #1}}
\newcommand{\maybe}[1]{\ensuremath{#1?}}
\newcommand{\many}[1]{\ensuremath{#1^*}}
\newcommand{\any}{\ensuremath{\text{\underline{\hspace{0.6em}}}}}
\newcommand{\none}{\ensuremath{\mathbf{none}}}
\newcommand{\bind}[2]{\ensuremath{#1@#2}}
\newcommand{\paction}[2]{\ensuremath{#1\mathop{\circ} #2}}
\newcommand{\fb}[1]{\ensuremath{\mathop{\rightarrow}(#1)}}
\newcommand{\nfb}[1]{\ensuremath{\mathop{\not\rightarrow}(#1)}}
\newcommand{\pin}[1]{\ensuremath{\mathit{In}(#1)}}
\newcommand{\pstart}{\ensuremath{\mathit{Start}}}
\newcommand{\pend}{\ensuremath{\mathit{End}}}

\newcommand{\arrayheading}[2]{\multicolumn{#1}{l}{\mbox{#2}}}

\synctex=1

\begin{document}

\section{Parsing in Trieste}

\[
  \begin{array}{rcl}
    \arrayheading{3}{Labels}\\
    \lbl  & \in & \{\Top, \Group, \Invalid, \Unclosed\}\cup \mathcal{L} \\
    \lbls & ::= & \lbl_1 .. \lbl_n\\
    \\
    \arrayheading{3}{Terms}\\
    \tm  & ::= & (\lbl~\tms) \\
    \tms & ::= & \tm ~ \tms ~|~ \epsilon \\
    \\
    \arrayheading{3}{Terms with a single cursor}\\
    \Tm  & ::= & (\lbl~\Tms)\\
    \Tms & ::= & \tm ~ \Tms ~|~ \Tm ~|~ \cursor\\
    \\
    \arrayheading{3}{Contexts (shallow)}\\
    \Tm[\bullet] & ::= & (\lbl~\Tms[\bullet])\\
    \Tms[\bullet] & ::= & \tm ~ \Tms[\bullet] ~|~ \bullet\\
    \\
    \arrayheading{3}{Actions}\\
    \action & ::= & \add{\lbl}\\
            & ~|~ & \push{\lbl}\\
            & ~|~ & \pop{\lbl}\\
            & ~|~ & \pseq{\lbl}\\
            & ~|~ & \term{\lbls}\\
            & ~|~ & \trypop{\lbl}\\
            & ~|~ & \invalid\\
            & ~|~ & \unclosed\\
            & ~|~ & \done\\
  \end{array}
\]

A term \tm{} is an $n$-ary tree where each node has a label \lbl.
%
During parsing, terms \Tm{} have a single cursor \cursor{} in them,
always ``furthest to the right'' in the tree.
%
We use $\Tm[\bullet]$ to denote a term whose right-most child is a
hole $\bullet$ that can be filled with a sequence of terms.

We use the rule \rn{ctx} to ``zoom in'' close enough to the cursor
to apply a rule. Actions \term{} and \done{} are always applied to
the whole term and are therefore excluded from being applied in a
context:


\[
\irule{ctx}{
\Tm_1 \steps{\action} \Tm_2\\
\action \notin \{\term, \done\}
}{
\Tm[\Tm_1] \steps{\action} \Tm[\Tm_2]
}
\]

The action \add{\lbl} will add a \lbl-term to a group and
advance the cursor, creating a new group and moving inside it if
the cursor is not already inside one:

\[
  \begin{array}{c}
    \irule{add-in}{}{
    (\Group~\Tms[\cursor]) \steps{\add{\lbl}} (\Group~\Tms[(\lbl) \cursor])
    }
    \\\\

    \irule{add-create}{
    \lbl' \neq \Group
    }{
    (\lbl'~\Tms[\cursor]) \steps{\add{\lbl}} (\lbl'~\Tms[(\Group~(\lbl) \cursor)])
    }
  \end{array}
\]

Pushing a label adds a term (creating a group if needed) and moves
the cursor inside it:

\[
  \begin{array}{c}
    \irule{push-in}{}{
    (\Group~\Tms[\cursor]) \steps{\push{\lbl}} (\Group~\Tms[(\lbl~\cursor)])
    }
    \\\\

    \irule{push-create}{
    \lbl' \neq \Group
    }{
    (\lbl'~\Tms[\cursor]) \steps{\push{\lbl}} (\lbl'~\Tms[(\Group~(\lbl~\cursor))])
    }
  \end{array}
\]

The action \pop{\lbl} moves the cursor out of the innermost term,
assuming its label is \lbl. If the label does not match, an
error is reported (defined below):

\[
  \begin{array}{c}
    \irule{pop-ok}{
    (\lbl'~\Tms[(\lbl~\Tms'[\cursor])]) \steps{\trypop{\lbl}} \Tm
    }{
    (\lbl'~\Tms[(\lbl~\Tms'[\cursor])]) \steps{\pop{\lbl}} \Tm
    }
    \\\\

    \irule{pop-fail}{
    \lbl'' \neq \lbl\\
    (\lbl''~\Tms'[\cursor]) \steps{\invalid} \Tm
    }{
    (\lbl'~\Tms[(\lbl''~\Tms'[\cursor])]) \steps{\pop{\lbl}}
    (\lbl'~\Tms[\Tm])
    }
  \end{array}
\]

Popping is done via an auxiliary action \trypop{\lbl} which does
nothing on a label mismatch:

\[
  \begin{array}{c}
    \irule{trypop-ok}{}{
    (\lbl'~\Tms[(\lbl~\Tms'[\cursor])]) \steps{\trypop{\lbl}}
    (\lbl'~\Tms[(\lbl~\Tms'[\epsilon])~\cursor])
    }
    \\\\
    \irule{trypop-fail}{
    \lbl'' \neq \lbl
    }{
    (\lbl'~\Tms[(\lbl''~\Tms'[\cursor])]) \steps{\trypop{\lbl}}
    (\lbl'~\Tms[(\lbl''~\Tms'[\cursor])])
    }
  \end{array}
\]

Errors are reported by adding a term with the label \Invalid. If
the cursor is already next to an \Invalid-term, the extent of
that error is extended (currently just modeled as a no-op) rather
than adding another \Invalid-term:

\[
  \begin{array}{c}
    \irule{invalid-extend}{}{
    (\lbl~\Tms[(\Invalid)~\cursor]) \steps{\invalid}
    (\lbl~\Tms[(\Invalid)~\cursor])
    }
    \\\\

    \irule{invalid-empty}{
    (\lbl~\cursor) \steps{\add{\Invalid}} \Tm
    }{
    (\lbl~\cursor) \steps{\invalid} \Tm
    }
    \\\\

    \irule{invalid-non-empty}{
    \lbl' \neq \Invalid\\
    (\lbl~\Tms[(\lbl'~\Tms') \cursor]) \steps{\add{\Invalid}} \Tm
    }{
    (\lbl~\Tms[(\lbl'~\Tms') \cursor]) \steps{\invalid} \Tm
    }
  \end{array}
\]

The action \seq{\lbl} finishes the current group and makes it a
child of a \lbl-term, creating that term if it is not the parent
of the current group. Performing the \seq{}-action when not in a
group is an error:

\[
  \begin{array}{c}
    \irule{seq-in}{}{
    (\lbl~\Tms[(\Group~\Tms'[\cursor])]) \steps{\seq{\lbl}}
    (\lbl~\Tms[(\Group~\Tms'[\epsilon])~\cursor])
    }\\\\
    \irule{seq-create}{
    \lbl' \neq \lbl
    }{
    (\lbl'~\Tms[(\Group~\Tms'[\cursor])]) \steps{\seq{\lbl}}
    (\lbl'~\Tms[(\lbl~(\Group~\Tms'[\epsilon])~\cursor)])
    }\\\\
    \irule{seq-fail}{
    \lbl' \neq \Group\\
    (\lbl'~\Tms[\cursor]) \steps{\invalid} \Tm{}
    }{
    (\lbl'~\Tms[\cursor]) \steps{\seq{\lbl}} \Tm{}
    }\\\\
  \end{array}
\]

The action \term{\lbls} finishes the current group (if any) and
tries to move out of enclosing terms in the order of the labels in
\lbls, ignoring any non-matching labels. Note that this rule may
use the \rn{ctx} rule to find the right level for popping.

\[
  \begin{array}{c}
    \irule{term}{
    \Tm \steps{\trypop{\Group}} \Tm_0\\
    \forall~i\in[1..n]. \Tm_{i-1} \steps{\trypop{\lbl_i}} \Tm_i
%    \lbl_2(\Tms_2[\lbl_3(\Tms_3[\cursor])]) \steps{\trypop{\Group}} \Tm\\
%    \lbl_1(\Tms_1[\Tm]) \steps{\trypop{\lbl}} \Tm'
    }{
    \Tm \steps{\term{\lbl_1..\lbl_n}} \Tm_n
%    \lbl_1(\Tms_1[\lbl_2(\Tms_2[\lbl_3(\Tms_3[\cursor])])]) \steps{\term{\lbl}}
%    \Tm'
    }
  \end{array}
\]

Finally, the \done{} action finishes the final group (if any) and
closes the top-most term, which must have label \Top{} (As an aside,
note that we can't use \trypop{\Group} as \trypop{} assumes that
the cursor is at least at depth 2, which is not true when the
cursor a direct child of the top term). Note that the resulting
term is a term without a cursor.

\[
  \begin{array}{c}
    \irule{done}{}{
    (\Top~\Tms[\cursor]) \steps{\done} (\Top~\Tms[\epsilon])
    }
    \\\\
    \irule{done-group}{}{
    (\Top~\Tms[(\Group~\Tms'[\cursor])]) \steps{\done} (\Top~\Tms[(\Group~\Tms'[\epsilon])])
    }
  \end{array}
\]

If the cursor is \emph{not} a direct child of the top node (or in
a group that is a direct child of the top node), parsing has
terminated prematurely and we add \Unclosed{} terms along the path
to the top until we can finish the term:

\[
  \begin{array}{c}
    \irule{done-unclosed}{
    \lbl \neq \Group\\
    (\Top~\Tms[(\lbl~\Tms')]) \steps{\unclosed} \tm\\
    }{
    (\Top~\Tms[(\lbl~\Tms')]) \steps{\done} \tm
    }
    \\\\
    \irule{unclosed-top}{}{
    (\Top~\Tms[\cursor]) \steps{\unclosed} \Top(\Tms[(\Unclosed)])
    }
    \\\\
    \irule{unclosed-step}{
    \Tm \steps{\unclosed} \Tm'\\
    \Tm' \steps{\unclosed} \tm
    }{
    \Tm \steps{\unclosed} \tm
    }
    \\\\
    \irule{unclosed-add}{
    \lbl' \neq \Group
    }{
    (\lbl~\Tms[(\lbl'~\Tms'[\cursor])]) \steps{\unclosed}\\
    (\lbl~\Tms[(\lbl'~\Tms'[(\Unclosed)]) \cursor])
    }
    \\\\
    \irule{unclosed-group}{}{
    (\lbl~\Tms[(\lbl'~\Tms'[(\Group~\Tms''[\cursor])])]) \steps{\unclosed}\\
    (\lbl~\Tms[(\lbl'~\Tms'[(\Group~\Tms''[\epsilon]) ~ (\Unclosed)]) \cursor])
    }
  \end{array}
\]

\section{Pattern Matching: Original Implementation}

\[
  \begin{array}{rcl}
    \arrayheading{3}{Terms with a sequence being matched}\\
    \Tmc & ::= & (\lbl~\Tmcs) ~|~ (\lbl~\tms~\select{\tms}~\tms)\\
    \Tmcs & ::= & \Tmc ~ \tms ~|~ \tm ~ \Tmcs\\
    \\
    \arrayheading{3}{Contexts (shallow)}\\
    \Tmc[\bullet] & ::= & (\lbl~\Tmcs[\bullet])\\
    \Tmcs[\bullet] & ::= & \bullet ~ \tms ~|~ \tm ~ \Tmcs[\bullet]\\
    \\
    \arrayheading{3}{Bindings}\\
    x, y      & \in & \mathcal{X}\\
    \bindings & \in & \mathcal{X} \mapsto \tms\\
    \\
    \multicolumn{3}{l}{
    \begin{array}{crll}
      \arrayheading{4}{Patterns}\\
      p & ::= & \lbl & \text{a term with label $\lbl$}\\
        & ~|~ & \pseq{p}{p} & \text{sequence}\\
        & ~|~ & \por{p}{p} & \text{choice}\\
        & ~|~ & \children{p}{p} & \text{with children}\\
        & ~|~ & \pnot{p} & \text{negation}\\
        & ~|~ & \maybe{p} & \text{option}\\
        & ~|~ & \many{p} & \text{repetition}\\
        & ~|~ & \any{} & \text{any term}\\
        & ~|~ & \bind{p}{x} & \text{bind}\\
        & ~|~ & \paction{p}{f} & \text{action}\\
        & ~|~ & \fb{p} & \text{followed by}\\
        & ~|~ & \nfb{p} & \text{not followed by}\\
        & ~|~ & \pin{\lbl} & \text{appears as child of}\\
        & ~|~ & \pstart{} & \text{before all children}\\
        & ~|~ & \pend{} & \text{after all children}\\
    \end{array}
    }\\
  \end{array}
\]
%
During matching we are selecting a sequence of sibling terms. A
term \Tmc{} is a term where one such sequence has been selected.
We represent the subterm whose children are being matched as
$(\lbl~\tms_{pre}~\select{\tms}~\tms_{post})$: a $\lbl$ term
where some subsequence $\tms$ of its children has been selected,
$\tms_{pre}$ being the terms before the match and $\tms_{post}$
the terms after the match. Matching commences by looking at terms
in $\tms_{post}$ and moving them into the matched sequence, or
equivalently, advancing the cursor $\mend$. Note that the coloring
has no semantic meaning.

The result of matching, apart from moving the cursor $\mend$, is a
set of bindings $\bindings$ which maps variables to sequences of
terms.
%
If the same variable name is used more than once, the later
binding is preferred. We write $\extend{\bindings_1}{\bindings_2}$
to mean the union of $\bindings_1$ and $\bindings_2$ where
bindings from $\bindings_2$ override overlapping bindings from
$\bindings_1$:

\[
    \extend{\bindings_1}{\bindings_2} = \bindings_2\cup \{x\mapsto \bindings_1(x) ~|~ x \in (\mathbf{dom}(\bindings_1)\setminus\mathbf{dom}(\bindings_2))\}
\]
%
The pattern matching rule takes the shape
$\matches{p}{\Tmc_1}{\Tmc_2}{\bindings}$, where we start from
$\Tmc_1$ and match $p$, (possibly) extending the selection
resulting in $\Tmc_2$ and the bindings $\bindings$.

Throughout, we use $\lbl_\pi$ as the label of the parent of the
nodes we are matching on.
%
Patterns $\bind{p}{x}$ which introduce a binding remembers the
terms that were matched in the resulting binding set:
%
\[
  \begin{array}{c}
    \irule{match-bind}{
    \matches{p}{(\lbl_\pi~\tms_{pre}~\select{\tms}~\tms_{post})}
               {(\lbl_\pi~\tms_{pre}~\select{\tms~\tms'}~\tms'_{post})}{\bindings}
    }{
    \xmatches{\bind{p}{x}}
    {(\lbl_\pi~\tms_{pre}~\select{\tms}~\tms_{post})}
    {(\lbl_\pi~\tms_{pre}~\select{\tms~\tms'}~\tms'_{post})}{\extend{\bindings} \{x\mapsto\tms'\}}
    }
  \end{array}
\]
%
% Patterns match on labels $\lbl$ (with $\any$ matching any label),
% and can be combined in several ways:

% \begin{itemize}
% \item $\pseq{p_1}{p_2}$     --- $p_1$ followed by $p_2$
% \item $\por{p_1}{p_2}$      --- $p_1$ or $p_2$
% \item $\children{p_1}{p_2}$ --- $p_1$ with children matching $p_2$
% \item $\pnot{p}$            --- not $p$
% \item $\maybe{p}$           --- optionally $p$
% \item $\many{p}$            --- zero or more $p$
% \end{itemize}
%
% We can bind the result of matching a subpattern to a name with
% the pattern $\bind{p}{x}$. There are also a number of patterns
% which do not advance the cursor:
%
% \begin{itemize}
% \item $\fb{p}$     --- followed by $p$
% \item $\nfb{p}$    --- not followed by $p$
% \item $\pin{\lbl}$ --- inside a node with label $\lbl$
% \item $\pstart{}$  --- before all children of the current term
% \item $\pend{}$    --- after all children of the current term
% \end{itemize}
%
\pstart{} and \pend{} match the very start and the very end
respectively of the full sequence of children:
%
\[
  \begin{array}{c}
    \irule{match-start}{}{
    \matches{\pstart}
    {(\lbl_\pi~\mstart\mend~\tms_{post})}
    {(\lbl_\pi~\mstart\mend~\tms_{post})}{\nobindings}
    }
    \\\\
    \irule{match-end}{}{
    \xmatches{\pend}
    {(\lbl_\pi~\tms_{pre}~\select{\tms})}
    {(\lbl_\pi~\tms_{pre}~\select{\tms})}{\nobindings}
    }
  \end{array}
\]
%
$\pin{\lbl}$ succeeds if we are matching directly inside a $\lbl$
term:

\[
  \begin{array}{c}
    \irule{match-in}{}{
    \xmatches{\pin{\lbl_\pi}}
    {(\lbl_\pi~\tms_{pre}~\select{\tms}~\tms_{post})}
    {(\lbl_\pi~\tms_{pre}~\select{\tms}~\tms_{post})}{\nobindings}
    }
  \end{array}
\]
%
The lookahead patterns $\fb{p}$ and $\nfb{p}$ tries the pattern
$p$, but does not advance the cursor nor remember bindings.

\[
  \begin{array}{c}
    \irule{match-followed-by}{
    \matches{p}{(\lbl_\pi~\tms_{pre}~\select{\tms}~\tms_{post})}{\Tmc}{\bindings}
    }{
    \xmatches{\fb{p}}
    {(\lbl_\pi~\tms_{pre}~\select{\tms}~\tms_{post})}
    {(\lbl_\pi~\tms_{pre}~\select{\tms}~\tms_{post})}{\nobindings}
    }
    \\\\
    \irule{match-not-followed-by}{
    \lnot(\matches{p}{(\lbl_\pi~\tms_{pre}~\select{\tms}~\tms_{post})}{\Tmc}){\bindings}
    }{
    \xmatches{\nfb{p}}
    {(\lbl_\pi~\tms_{pre}~\select{\tms}~\tms_{post})}
    {(\lbl_\pi~\tms_{pre}~\select{\tms}~\tms_{post})}{\nobindings}
    }
  \end{array}
\]
%
Matching on a label $\lbl$ succeeds if it is the next label.
Matching on a wild-card always succeeds as long as there is a term
to match on:

\[
  \begin{array}{c}
    \irule{match-label}{}{
    \xmatches{\lbl}
    {(\lbl_\pi~\tms_{pre}~\select{\tms}~(\lbl~\tms')~\tms_{post})}
    {(\lbl_\pi~\tms_{pre}~\select{\tms~(\lbl~\tms')}~\tms_{post})}{\nobindings}
    }
    \\\\
    \irule{match-any}{}{
    \xmatches{\any}
    {(\lbl_\pi~\tms_{pre}~\select{\tms}~(\lbl~\tms')~\tms_{post})}
    {(\lbl_\pi~\tms_{pre}~\select{\tms~(\lbl~\tms')}~\tms_{post})}{\nobindings}
    }
  \end{array}
\]
%
Patterns in sequence are matched left to right, with later
bindings being preferred over earlier:

\[
  \begin{array}{c}
    \irule{match-sequence}{
    \matches{p_1}{(\lbl_\pi~\tms_{pre}~\select{\tms}~\tms_{post})}{\Tmc_1}{\bindings_1}\\
    \matches{p_2}{\Tmc_1}{\Tmc_2}{\bindings_2}\\
    }{
    \matches{\pseq{p_1}{p_2}}
    {(\lbl_\pi~\tms_{pre}~\select{\tms}~\tms_{post})}
    {\Tmc_2}{\extend{\bindings_1}{\bindings_2}}
    }
  \end{array}
\]

Alternative patterns $\por{p_1}{p_2}$ picks the first of the two
patterns that matches [Could not be zoomed in?]:

\[
  \begin{array}{c}
    \irule{match-or-l}{
    \matches{p_1}{(\lbl_\pi~\tms_{pre}~\select{\tms}~\tms_{post})}{\Tmc}{\bindings}
    }{
    \matches{\por{p_1}{p_2}}
    {(\lbl_\pi~\tms_{pre}~\select{\tms}~\tms_{post})}
    {\Tmc}{\bindings}
    }
    \\\\
    \irule{match-or-r}{
    \lnot(\matches{p_1}{(\lbl_\pi~\tms_{pre}~\select{\tms}~\tms_{post})}{\Tmc_1}{\bindings_1})\\
    \matches{p_2}{(\lbl_\pi~\tms_{pre}~\select{\tms}~\tms_{post})}{\Tmc_2}{\bindings_2}
    }{
    \matches{\por{p_1}{p_2}}
    {(\lbl_\pi~\tms_{pre}~\select{\tms}~\tms_{post})}
    {\Tmc_2}{\bindings_2}
    }
  \end{array}
\]

The rule for matching children $\children{p_1}{p_2}$ is probably
the most complicated. First, the pattern $p_1$ matches normally
and defines the movement of the cursor to include $\tms_1$.
Additionally, we extract the first term $(\lbl~\tms_{11})$ inside
which we match $p_2$. We transfer the bindings from the inner
match to the final results, preferring these bindings to ones from
the outer match.
%
Note that $p_1$ must match at least one term.

\[
  \begin{array}{c}
    \irule{match-children}{
    \matches{p_1}{(\lbl_\pi~\tms_{pre}~\select{\tms}~\tms_{post})}
                 {(\lbl_\pi~\tms_{pre}~\select{\tms~\tms_1}~\tms'_{post})}{\bindings_1}\\
    \tms_1 = (\lbl~\tms_{11})~\tms'_1\\
    \matches{p_2}{(\lbl~\mstart\mend~\tms_{11})}{\Tmc}{\bindings_2}
    }{
    \xmatches{\children{p_1}{p_2}}
    {(\lbl_\pi~\tms_{pre}~\select{\tms}~\tms_{post})}
    {(\lbl_\pi~\tms_{pre}~\select{\tms~\tms_1}~\tms'_{post})}
    {\extend{\bindings_1}{\bindings_2}}
    }
  \end{array}
\]

The negation of a pattern $\pnot{p}$ matches the subsequent term
if $p$ does \emph{not} match. Note that this means that the next
term is consumed regardless of whether the pattern $p$ consumes
zero or more than one term:

\[
  \begin{array}{c}
    \irule{match-not}{
    \lnot(\matches{p}{(\lbl_\pi~\tms_{pre}~\select{\tms}~(\lbl~\tms')~\tms_{post})}{\Tmc}{\bindings})
    }{
    \xmatches{\pnot{p}}
    {(\lbl_\pi~\tms_{pre}~\select{\tms}~(\lbl~\tms')~\tms_{post})}
    {(\lbl_\pi~\tms_{pre}~\select{\tms~(\lbl~\tms')}~\tms_{post})}{\nobindings}
    }
  \end{array}
\]

Optional matches $\maybe{p}$ always succeeds, but matches $p$ if
possible:

\[
  \begin{array}{c}
    \irule{match-option-yes}{
    \matches{p}{(\lbl_\pi~\tms_{pre}~\select{\tms}~\tms_{post})}{\Tmc}{\bindings}
    }{
    \matches{\maybe{p}}
    {(\lbl_\pi~\tms_{pre}~\select{\tms}~\tms_{post})}
    {\Tmc}{\bindings}
    }
    \\
    \\
    \irule{match-option-no}{
    \lnot(\matches{p}{(\lbl_\pi~\tms_{pre}~\select{\tms}~\tms_{post})}{\Tmc}{\bindings})
    }{
    \xmatches{\maybe{p}}
    {(\lbl_\pi~\tms_{pre}~\select{\tms}~\tms_{post})}
    {(\lbl_\pi~\tms_{pre}~\select{\tms}~\tms_{post})}{\nobindings}
    }
  \end{array}
\]

Repetition of a pattern $\many{p}$ will greedily match $p$ as many
times as possible, preferring later bindings to earlier:

\[
  \begin{array}{c}
    \irule{match-many-more}{
    \matches{p}{(\lbl_\pi~\tms_{pre}~\select{\tms}~\tms_{post})}{\Tmc_1}{\bindings_1}\\
    \matches{\many{p}}{\Tmc_1}{\Tmc_2}{\bindings_2}
    }{
    \matches{\many{p}}
    {(\lbl_\pi~\tms_{pre}~\select{\tms}~\tms_{post})}
    {\Tmc_2}{\extend{\bindings_1}{\bindings_2}}
    }
    \\\\
    \irule{match-many-done}{
    \lnot(\matches{p}{(\lbl_\pi~\tms_{pre}~\select{\tms}~\tms_{post})}{\Tmc}{\bindings})
    }{
    \xmatches{\many{p}}
    {(\lbl_\pi~\tms_{pre}~\select{\tms}~\tms_{post})}
    {(\lbl_\pi~\tms_{pre}~\select{\tms}~\tms_{post})}{\nobindings}
    }
  \end{array}
\]

An action pattern $\paction{p}{f}$ comes equipped with a function
$f : \tms \mapsto \mathbf{bool}$ which must return $\mathbf{true}$
for the matched pattern:

\[
  \begin{array}{c}
    \irule{match-action}{
    \matches{p}{(\lbl_\pi~\tms_{pre}~\select{\tms}~\tms_{post})}
               {(\lbl_\pi~\tms_{pre}~\select{\tms~\tms'}~\tms'_{post})}{\bindings}\\
    f(\tms') = \mathbf{true}
    }{
    \xmatches{\paction{p}{f}}
    {(\lbl_\pi~\tms_{pre}~\select{\tms}~\tms_{post})}
    {(\lbl_\pi~\tms_{pre}~\select{\tms~\tms'}~\tms'_{post})}{\bindings}
    }
  \end{array}
\]


As with parsing, we use contexts to ``zoom in'' until we can apply
a matching rule:

\[
  \begin{array}{c}
    \irule{match-ctx}{
    \matches{p}{\Tmc_1}{\Tmc_2}{\bindings}
    }{
    \matches{p}{\Tmc[\Tmc_1]}{\Tmc[\Tmc_2]}{\bindings}
    }
  \end{array}
\]

\section{New Suggestion for Pattern Matching}

\[
  \begin{array}{crll}
    \arrayheading{4}{Predicates}\\
      \phi & ::= & \fb{p}      & \text{followed by}         \\
           & ~|~ & \pin{\lbl}  & \text{appears as child of} \\
           & ~|~ & \pstart{}   & \text{before all children} \\
           & ~|~ & \pend{}     & \text{after all children}  \\
           & ~|~ & \pnot{\phi} & \text{negation}            \\
    \\
    \arrayheading{4}{Patterns}\\
      p & ::= & \phi            & \text{predicate}                          \\
        & ~|~ & \lbls           & \text{a term with label in $\lbls$}       \\
        & ~|~ & !\lbls          & \text{a term with a label not in $\lbls$} \\
        & ~|~ & \any{}          & \text{any single term}                    \\
        & ~|~ & \por{p}{p}      & \text{choice}                             \\
        & ~|~ & \pseq{p}{p}     & \text{sequence}                           \\
        & ~|~ & \children{p}{p} & \text{children}                           \\
        & ~|~ & \maybe{p}       & \text{option}                             \\
        & ~|~ & \many{p}        & \text{repetition}                         \\
        & ~|~ & \bind{p}{x}     & \text{bind}                               \\
        & ~|~ & \paction{p}{f}  & \text{action}                             \\
    \\
    \arrayheading{4}{Multiplicities}\\
    \Gamma & ::= & \Gamma, x : m ~|~ \epsilon & \text{multiplicity mapping}\\
    m      & ::= & 0 ~|~ 1 ~|~ \omega & \text{multiplicities}
  \end{array}
\]
%
This new design works under the hypothesis that negation is used
for two different things: consuming exactly one term that is not
among a set of labels and for doing negative lookahead.
%
In addition to pattern matching we define well-formedness rules
where each variable binding is associated with a
\emph{multiplicity} denoting the length of the sequence of terms
matched -- $0$, $1$ or an unknown number $\omega$. This helps rule
out some bad cases, such as taking the children of zero terms.

\TODO{This formulation requires a workaround for the pattern
  $\many{(\pnot{(\por{(\children{\mathit{foo}}{p_1})}{(\children{\mathit{bar}}{p_2})})})}$.
  Would it work to have negation at the top-level but disallow
  negation of $\omega$ patterns?}

Multiplicities of patterns are calculated as $\mu(p)$:

\[
  \begin{array}{rcl}
    \mu(\phi)                & = & 0                         \\
    \mu(\lbls)               & = & 1                         \\
    \mu(!\lbls)              & = & 1                         \\
    \mu(\any)                & = & 1                         \\
    \mu(\por{p_1}{p_2})      & = & \mu(p_1) \oslash \mu(p_2) \\
    \mu(\pseq{p_1}{p_2})     & = & \mu(p_1) \oplus \mu(p_2)  \\
    \mu(\children{p_1}{p_2}) & = & \mu(p_1)                  \\
    \mu(\maybe{p})           & = & \omega                    \\
    \mu(\many{p})            & = & \omega                    \\
    \mu(\bind{p}{x})         & = & \mu(p)                    \\
    \mu(\paction{p}{f})      & = & \mu(p)                    \\
  \end{array}
\]

We define the following operations on multiplicities:

$
  m_1 \oplus m_2 =
  \begin{cases}
    0 & \text{if $m_1 = m_2 = 0$}\\
    1 & \text{if $m_1 = 0$ and $m_2 = 1$ or $m_1 = 1$ and $m_2 = 0$}\\
    \omega & \text{otherwise}\\
  \end{cases}
$

$
  m_1 \otimes m_2 =
  \begin{cases}
    0 & \text{if $m_1 = 0$ or $m_2 = 0$}\\
    m_1 & \text{if $m_2 = 1$}\\
    m_2 & \text{if $m_1 = 1$}\\
    \omega & \text{otherwise}\\
  \end{cases}
$

$
  m_1 \oslash m_2 =
  \begin{cases}
    0 & \text{if $m_1 = m_2 = 0$}\\
    1 & \text{if $m_1 = m_2 = 1$}\\
    \omega & \text{otherwise}\\
  \end{cases}
$

\noindent
We lift operations on multiplicities in the expected way:

\[
  m \odot \Gamma =
  \begin{cases}
    (m \odot \Gamma'), x : (m \odot m') & \text{if } \Gamma = \Gamma', x : m'\\
    \epsilon & \text{otherwise}
  \end{cases}
\]
%
All the predicates are well-formed if their nested patterns are
well-formed. Any bindings in the nested patterns are discarded.
%
The atomic single term patterns trivially have no bindings.

\[
  \begin{array}{c}
    \irule{wf-followed-by}{
    \wfp{\Gamma}{p}
    }{
    \wfp{\epsilon}{\fb{p}}
    }
    \quad
    \irule{wf-not}{
    \lnot(\wfp{\Gamma}{\phi})
    }{
    \wfp{\epsilon}{\pnot{\phi}}
    }
    \\\\
    \irule{wf-in}{
    }{
    \wfp{\epsilon}{\pin{\lbl}}
    }
    \quad
    \irule{wf-start}{
    }{
    \wfp{\epsilon}{\pstart}
    }
    \quad
    \irule{wf-end}{
    }{
    \wfp{\epsilon}{\pend}
    }
    \\\\
    \irule{wf-labels}{
    }{
    \wfp{\epsilon}{\lbls}
    }
    \quad
    \irule{wf-not-labels}{
    }{
    \wfp{\epsilon}{!\lbls}
    }
    \quad
    \irule{wf-any}{
    }{
    \wfp{\epsilon}{\any}
    }
  \end{array}
\]
%
For choice, bindings must overlap. The resulting multiplicity for
bindings in a choice is $\omega$ unless the overlapping bindings
have the same multiplicity.

\[
  \begin{array}{c}
    \irule{wf-choice}{
    \wfp{\Gamma_1}{p_1}
    \quad
    \wfp{\Gamma_2}{p_2}\\
    \mathbf{dom}(\Gamma_1) = \mathbf{dom}(\Gamma_2)
    }{
    \wfp{\Gamma_1 \oslash \Gamma_2}{\por{p_1}{p_2}}
    }
  \end{array}
\]
%
The sequences and children patterns produce the union of their
bindings and disallow overlapping bindings. The root of the
children pattern must have multiplicity $1$.
%
Optional and repeating patterns give bindings in nested patterns
the multiplicity $\omega$, since we don't know if they consume
anything.

\[
  \begin{array}{c}
    \irule{wf-seq}{
    \wfp{\Gamma_1}{p_1}\quad
    \wfp{\Gamma_2}{p_2}\\
    \mathbf{dom}(\Gamma_1) \cap \mathbf{dom}(\Gamma_2) = \emptyset
    }{
    \wfp{\Gamma_1, \Gamma_2}{\pseq{p_1}{p_2}}
    }
    \quad
    \irule{wf-children}{
    \mu(p_1) = 1
    \quad
    \wfp{\Gamma_1}{p_1}
    \quad
    \wfp{\Gamma_2}{p_2}\\
    \mathbf{dom}(\Gamma_1) \cap \mathbf{dom}(\Gamma_2) = \emptyset
    }{
    \wfp{\Gamma_1, \Gamma_2}{\children{p_1}{p_2}}
    }
    \\\\
    \irule{wf-option}{
    \wfp{\Gamma}{p}
    }{
    \wfp{\omega \oplus \Gamma}{\maybe{p}}
    }
    \quad
    \irule{wf-many}{
    \wfp{\Gamma}{p}
    }{
    \wfp{\omega \oplus \Gamma}{\many{p}}
    }
  \end{array}
\]
%
A bound variable must not be repeated in the same pattern and gets
the multiplicity of the underlying pattern. Actions are ignored.
\[
  \begin{array}{c}
    \irule{wf-bind}{
    \wfp{\Gamma}{p}
    \quad
    x \notin{\mathbf{dom}(\Gamma)}
    }{
    \wfp{\Gamma, x : \mu(p)}{\bind{p}{x}}
    }
    \quad
    \irule{wf-action}{
    \wfp{\Gamma}{p}
    }{
    \wfp{\Gamma}{\paction{p}{f}}
    }
  \end{array}
\]
%
A different version of the children pattern allows the root to
have any multiplicity, and then multiplies the bindings in the
child pattern by that multiplicity. Note that this requires the
dynamic matching rule to fail when the root matches zero terms.

\[
  \begin{array}{c}
    \irule{wf-children-alt}{
    \mu(p_1) = m
    \quad
    \wfp{\Gamma_1}{p_1}
    \quad
    \wfp{\Gamma_2}{p_2}\\
    \mathbf{dom}(\Gamma_1) \cap \mathbf{dom}(\Gamma_2) = \emptyset
    }{
    \wfp{\Gamma_1, m \otimes \Gamma_2}{\children{p_1}{p_2}}
    }
  \end{array}
\]
%
What this gives us is the ability to concatenate the children of
several terms. For example, we can get the first children of a
$\mathit{foo}$ followed by a $\mathit{bar}$:

\[
  \wfp{x : \omega}{\children{(\pseq{\mathit{foo}}{\mathit{bar}})}{(\bind{\any}{x})}}
\]
%
Note that the static rule for \many{p} already allows for the
semantics that concatenates bindings under $p$.

\subsection{Pattern Matching}

\[
  \begin{array}{rcl}
    \arrayheading{3}{Terms with a sequence being matched}\\
    \Tmc & ::= & (\lbl~\Tmcs) ~|~ (\lbl~\tms~\select{\tms}~\tms)\\
    \Tmcs & ::= & \Tmc ~ \tms ~|~ \tm ~ \Tmcs\\
    \\
    \arrayheading{3}{Contexts (shallow)}\\
    \Tmc[\bullet] & ::= & (\lbl~\Tmcs[\bullet])\\
    \Tmcs[\bullet] & ::= & \bullet ~ \tms ~|~ \tm ~ \Tmcs[\bullet]\\
    \\
    \arrayheading{3}{Bindings}\\
    x         & \in & \mathcal{X}\\
    \bindings & \in & \mathcal{X} \mapsto \tms\\
    % \\
    % \multicolumn{3}{l}{
    % \begin{array}{crll}
    % \arrayheading{4}{Patterns}\\
    %   \phi & ::= & \fb{p}      & \text{followed by}         \\
    %        & ~|~ & \pin{\lbl}  & \text{appears as child of} \\
    %        & ~|~ & \pstart{}   & \text{before all children} \\
    %        & ~|~ & \pend{}     & \text{after all children}  \\
    %        & ~|~ & \pnot{\phi} & \text{negation}            \\
    %   \\
    %   p & ::= & \phi            & \text{predicate}                          \\
    %     & ~|~ & \lbls           & \text{a term with label in $\lbls$}       \\
    %     & ~|~ & !\lbls          & \text{a term with a label not in $\lbls$} \\
    %     & ~|~ & \any{}          & \text{any single term}                    \\
    %     & ~|~ & \por{p}{p}      & \text{choice}                             \\
    %     & ~|~ & \pseq{p}{p}     & \text{sequence}                           \\
    %     & ~|~ & \children{p}{p} & \text{children}                           \\
    %     & ~|~ & \maybe{p}       & \text{option}                             \\
    %     & ~|~ & \many{p}        & \text{repetition}                         \\
    %     & ~|~ & \bind{p}{x}     & \text{bind}                               \\
    %     & ~|~ & \paction{p}{f}  & \text{action}                             \\
    % \end{array}
    % }
  \end{array}
\]
%
The pattern matching rule takes the shape
$\matches{p}{\Tmc_1}{\Tmc_2}{\bindings}$, where we start from
$\Tmc_1$ and match $p$, (possibly) extending the selection
resulting in $\Tmc_2$ and the bindings $\bindings$.

Throughout, we use $\lbl_\pi$ as the label of the parent of the
nodes we are matching on.
%
Patterns $\bind{p}{x}$ introduce a binding and remembers the terms
that were matched in the resulting binding set:

\[
  \begin{array}{c}
    \irule{match-bind}{
    \xmatches{p}{(\lbl_\pi~\tms_{pre}~\select{\tms}~\tms_{post})}
                {(\lbl_\pi~\tms_{pre}~\select{\tms~\tms'}~\tms'_{post})}{\bindings}
    }{
    \xmatches{\bind{p}{x}}
    {(\lbl_\pi~\tms_{pre}~\select{\tms}~\tms_{post})}
    {(\lbl_\pi~\tms_{pre}~\select{\tms~\tms'}~\tms'_{post})}{\extend{\bindings}{\{x\mapsto \tms'\}}}
    }
  \end{array}
\]
%
\pstart{} and \pend{} match the very start and the very end
respectively of the full sequence of children:

\[
  \begin{array}{c}
    \irule{match-start}{}{
    \matches{\pstart}
    {(\lbl_\pi~\mstart\mend~\tms_{post})}
    {(\lbl_\pi~\mstart\mend~\tms_{post})}{\nobindings}
    }
    \\\\
    \irule{match-end}{}{
    \xmatches{\pend}
    {(\lbl_\pi~\tms_{pre}~\select{\tms})}
    {(\lbl_\pi~\tms_{pre}~\select{\tms})}{\nobindings}
    }
  \end{array}
\]
%
$\pin{\lbl}$ succeeds if we are matching directly inside a $\lbl$
term:

\[
  \begin{array}{c}
    \irule{match-in}{}{
    \xmatches{\pin{\lbl_\pi}}
    {(\lbl_\pi~\tms_{pre}~\select{\tms}~\tms_{post})}
    {(\lbl_\pi~\tms_{pre}~\select{\tms}~\tms_{post})}{\nobindings}
    }
  \end{array}
\]
%
The lookahead pattern $\fb{p}$ tries the pattern $p$, but does not
advance the cursor nor remember bindings.

\[
  \begin{array}{c}
    \irule{match-followed-by}{
    \matches{p}{(\lbl_\pi~\tms_{pre}~\select{\tms}~\tms_{post})}{\Tmc}{\bindings}
    }{
    \xmatches{\fb{p}}
    {(\lbl_\pi~\tms_{pre}~\select{\tms}~\tms_{post})}
    {(\lbl_\pi~\tms_{pre}~\select{\tms}~\tms_{post})}{\nobindings}
    }
  \end{array}
\]
%
Negation $\pnot{\phi}$ succeeds if the predicate $\phi$ does not
succeed. It does not advance the cursor nor remember bindings.

\[
  \begin{array}{c}
    \irule{match-not}{
    \lnot(\matches{\phi}{(\lbl_\pi~\tms_{pre}~\select{\tms}~\tms_{post})}{\Tmc}{\bindings})
    }{
    \xmatches{\pnot{\phi}}
    {(\lbl_\pi~\tms_{pre}~\select{\tms}~\tms_{post})}
    {(\lbl_\pi~\tms_{pre}~\select{\tms}~\tms_{post})}{\nobindings}
    }
  \end{array}
\]
%
Matching on positive labels $\lbls$ succeeds if the label of the
next term is in the pattern. Matching on negative labels $!\lbls$
succeeds if the label of the next term is \emph{not} in $\lbls$.
Matching on a wild-card \any{} always succeeds as long as there is
a term to match on.

\[
  \begin{array}{c}
    \irule{match-labels}{
    \lbl \in \lbls
    }{
    \xmatches{\lbls}
    {(\lbl_\pi~\tms_{pre}~\select{\tms}~(\lbl~\tms')~\tms_{post})}
    {(\lbl_\pi~\tms_{pre}~\select{\tms~(\lbl~\tms')}~\tms_{post})}{\nobindings}
    }
    \\\\
    \irule{match-not-labels}{\lbl \notin \lbls}{
    \xmatches{!\lbls}
    {(\lbl_\pi~\tms_{pre}~\select{\tms}~(\lbl~\tms')~\tms_{post})}
    {(\lbl_\pi~\tms_{pre}~\select{\tms~(\lbl~\tms')}~\tms_{post})}{\nobindings}
    }
    \\\\
    \irule{match-any}{}{
    \xmatches{\any}
    {(\lbl_\pi~\tms_{pre}~\select{\tms}~(\lbl~\tms')~\tms_{post})}
    {(\lbl_\pi~\tms_{pre}~\select{\tms~(\lbl~\tms')}~\tms_{post})}{\nobindings}
    }
  \end{array}
\]
%
Matching choice $\por{p_1}{p_2}$ works as expected. Note that
choice is \emph{ordered}, meaning the first pattern is preferred
if both patterns match.

\[
  \begin{array}{c}
    \irule{match-choice-l}{
    \matches{p_1}{(\lbl_\pi~\tms_{pre}~\select{\tms}~\tms_{post})}{\Tmc}{\bindings}
    }{
    \matches{\por{p_1}{p_2}}
    {(\lbl_\pi~\tms_{pre}~\select{\tms}~\tms_{post})}
    {\Tmc}{\bindings}
    }
    \\\\
    \irule{match-choice-r}{
    \lnot\left(\matches{p_1}{(\lbl_\pi~\tms_{pre}~\select{\tms}~\tms_{post})}{\Tmc_1}{\bindings_1}\right)\\
    \matches{p_2}{(\lbl_\pi~\tms_{pre}~\select{\tms}~\tms_{post})}{\Tmc_2}{\bindings_2}
    }{
    \matches{\por{p_1}{p_2}}
    {(\lbl_\pi~\tms_{pre}~\select{\tms}~\tms_{post})}
    {\Tmc_2}{\bindings_2}
    }
  \end{array}
\]
%
Matching a sequence $\pseq{p_1}{p_2}$ concatenates the results of the match.

\[
  \begin{array}{c}
    \irule{match-sequence}{
    \matches{p_1}{(\lbl_\pi~\tms_{pre}~\select{\tms}~\tms_{post})}{\Tmc_1}{\bindings_1}\\
    \matches{p_2}{\Tmc_1}{\Tmc_2}{\bindings_2}\\
    }{
    \matches{\pseq{p_1}{p_2}}
    {(\lbl_\pi~\tms_{pre}~\select{\tms}~\tms_{post})}
    {\Tmc_2}{\extend{\bindings_1}{\bindings_2}}
    }
  \end{array}
\]
%
Matching children $\children{p_1}{p_2}$ first uses $p_1$ to match
a single node, and then further requires that $p_2$ matches its
children (we don't care about \emph{which} terms are matched
here). We transfer the bindings from the inner match to the final
result.

\[
  \begin{array}{c}
    \irule{match-children}{
    \xmatches{p_1}{(\lbl_\pi~\tms_{pre}~\select{\tms}~(\lbl~\tms_1)~\tms_{post})}
                  {(\lbl_\pi~\tms_{pre}~\select{\tms~(\lbl~\tms_1)}~\tms_{post})}{\bindings_1}\\
    \matches{p_2}{(\lbl~\mstart\mend~\tms_1)}{\Tmc}{\bindings_2}
    }{
    \xmatches{\children{p_1}{p_2}}
    {(\lbl_\pi~\tms_{pre}~\select{\tms}~(\lbl~\tms_1)~\tms_{post})}
    {(\lbl_\pi~\tms_{pre}~\select{\tms~(\lbl~\tms_1)}~\tms_{post})}
    {\extend{\bindings_1}{\bindings_2}}
    }
  \end{array}
\]
%
Optional matches $\maybe{p}$ always succeed, but matches $p$ if
possible.

\[
  \begin{array}{c}
    \irule{match-option-yes}{
    \matches{p}{(\lbl_\pi~\tms_{pre}~\select{\tms}~\tms_{post})}{\Tmc}{\bindings}
    }{
    \matches{\maybe{p}}
    {(\lbl_\pi~\tms_{pre}~\select{\tms}~\tms_{post})}
    {\Tmc}{\bindings}
    }
    \\
    \\
    \irule{match-option-no}{
    \lnot\left(\matches{p}{(\lbl_\pi~\tms_{pre}~\select{\tms}~\tms_{post})}{\Tmc}{\bindings}\right)
    }{
    \xmatches{\maybe{p}}
    {(\lbl_\pi~\tms_{pre}~\select{\tms}~\tms_{post})}
    {(\lbl_\pi~\tms_{pre}~\select{\tms}~\tms_{post})}{\nobindings}
    }
  \end{array}
\]
%
Repetition of a pattern $\many{p}$ will greedily match $p$ as many
times as possible, preferring later bindings to earlier:

\[
  \begin{array}{c}
    \irule{match-many-more}{
    \matches{p}{(\lbl_\pi~\tms_{pre}~\select{\tms}~\tms_{post})}{\Tmc_1}{\bindings_1}\\
    \matches{\many{p}}{\Tmc_1}{\Tmc_2}{\bindings_2}
    }{
    \matches{\many{p}}
    {(\lbl_\pi~\tms_{pre}~\select{\tms}~\tms_{post})}
    {\Tmc_2}{\extend{\bindings_1}{\bindings_2}}
    }
    \\\\
    \irule{match-many-done}{
    \lnot\left(\matches{p}{(\lbl_\pi~\tms_{pre}~\select{\tms}~\tms_{post})}{\Tmc}{\bindings}\right)
    }{
    \xmatches{\many{p}}
    {(\lbl_\pi~\tms_{pre}~\select{\tms}~\tms_{post})}
    {(\lbl_\pi~\tms_{pre}~\select{\tms}~\tms_{post})}{\nobindings}
    }
  \end{array}
\]
%
An action pattern $\paction{p}{f}$ comes equipped with a function
$f : \tms \mapsto \mathbf{bool}$ which must return $\mathbf{true}$
for the matched pattern:

\[
  \begin{array}{c}
    \irule{match-action}{
    \matches{p}{(\lbl_\pi~\tms_{pre}~\select{\tms}~\tms_{post})}
               {(\lbl_\pi~\tms_{pre}~\select{\tms~\tms'}~\tms'_{post})}{\bindings}\\
    f(\tms') = \mathbf{true}
    }{
    \xmatches{\paction{p}{f}}
    {(\lbl_\pi~\tms_{pre}~\select{\tms}~\tms_{post})}
    {(\lbl_\pi~\tms_{pre}~\select{\tms~\tms'}~\tms'_{post})}{\bindings}
    }
  \end{array}
\]
%
As with parsing, we use contexts to ``zoom in'' until we can apply
a matching rule:

\[
  \begin{array}{c}
    \irule{match-ctx}{
    \matches{p}{\Tmc_1}{\Tmc_2}{\bindings}
    }{
    \matches{p}{\Tmc[\Tmc_1]}{\Tmc[\Tmc_2]}{\bindings}
    }
  \end{array}
\]
%
We can allow an alternative semantics for children and repetition,
in which repeated bindings are concatenated. Note that we require
the root of children to match at least one term.

\[
  \begin{array}{c}
    \irule{match-many-more-alt}{
    \matches{p}{(\lbl_\pi~\tms_{pre}~\select{\tms}~\tms_{post})}{\Tmc_1}{\bindings_1}\\
    \matches{\many{p}}{\Tmc_1}{\Tmc_2}{\bindings_2}
    }{
    \matches{\many{p}}
    {(\lbl_\pi~\tms_{pre}~\select{\tms}~\tms_{post})}
    {\Tmc_2}{\bindings_1\concat\bindings_2}
    }
    \\\\
    \irule{match-many-done-alt}{
    \lnot\left(\matches{p}{(\lbl_\pi~\tms_{pre}~\select{\tms}~\tms_{post})}{\Tmc}{\bindings}\right)
    }{
    \xmatches{\many{p}}
    {(\lbl_\pi~\tms_{pre}~\select{\tms}~\tms_{post})}
    {(\lbl_\pi~\tms_{pre}~\select{\tms}~\tms_{post})}{\nobindings}
    }
    \\\\
    \irule{match-children-alt}{
    \xmatches{p_1}{(\lbl_\pi~\tms_{pre}~\select{\tms}~\tms_{post})}
                  {(\lbl_\pi~\tms_{pre}~\select{\tms~\tms'}~\tms'_{post})}{\bindings_0}\\
    \tms' = (\lbl_1~\tms_1) \ldots (\lbl_n~\tms_n)\quad n > 0\\
    \forall i \in [1..n].~\matches{p_2}{(\lbl_i~\mstart\mend~\tms_i)}{\Tmc_i}{\bindings_i}
    }{
    \xmatches{\children{p_1}{p_2}}
    {(\lbl_\pi~\tms_{pre}~\select{\tms}~\tms_{post})}
    {(\lbl_\pi~\tms_{pre}~\select{\tms~\tms'}~\tms'_{post})}
    {\extend{\bindings_0}{(\bindings_1\concat\ldots\concat\bindings_n)}}
    }
  \end{array}
\]
%
Concatenation of bindings is defined as the concatenation of the
results of their overlapping bindings.

\[
  \begin{array}{l}
    \bindings_1 \concat \bindings_2 =
      \{x \mapsto (\tms_1 \concat \tms_2) ~|~
        \bindings_1(x) = \tms_1 ~\land~
        \bindings'_2(x) = \tms_2
      \}
    \\\\\quad
    \text{ where } \bindings'_2(x) =
    \begin{cases}
      \bindings_2(x) & \text{if } x \in \mathbf{dom}(\bindings_2)\\
      \epsilon & \text{otherwise}
    \end{cases}
  \end{array}
\]


\subsection{Thoughts}

\begin{itemize}
\item We should really have choice (and conjunction?) at the
  top-level, to be able to allow, e.g.,
  $\por{(\pseq{\pin{\lbl}}{\mathit{foo}})}{bar}$. We could allow
  negation of choice if we had conjunction at the top-level, but
  we do not want general negation.
\item We could have patterns $\mathit{lbls}$ and $!\mathit{lbls}$
  for disjunctive positive and conjunctive negative single term
  patterns respectively.
\item We could use the type system to say that you can get the
  children of anything as long as it has multiplicity $1$.
\item Should we allow overriding bindings? We could allow it in
  the matching semantics if we want well-formedness to be opt-in.
\item The \none{} pattern isn't quite right. We would like to have
  the property that if a pattern $p$ does not match, then the
  negation of the pattern \pnot{p} does match (and vice versa).
  The pattern \any{} does not match on the empty sequence, but
  neither does its negation \none{} (since it never matches).
  Similarly, \none{} does not match on the empty sequence, but
  neither does its negation \any{} (since it requires at least one
  term).
  \begin{itemize}
  \item Akhshualy, if you have an empty sequence, all $s$ patterns
    have the same issue as above! So maybe \none{} is back on the
    table.
  \end{itemize}
\item \any{} is equivalent to \por{\pnot{a}}{\pnot{b}} for
  disjoint $a$ and $b$.
\item Does it make sense to bind within $\fb{p}$?
\end{itemize}
%
Annoying things:

\begin{itemize}
\item We cannot define $\lnot(\lnot p) = p$, since that would
  require negation of general patterns, which does not make sense.
\item $|\lnot p| = |p|$ except for $\any$, where $|\lnot\any| = 0$
  \TODO{Actually, we could think of \any{} as ``match a single
    term with any label'', and then \pnot{\any{}} would be a
    pattern that never succeeds}
\end{itemize}
%
Possibly reasonable things:

\begin{itemize}
\item $\lnot \pin{\lbl}$
\item $\lnot (\pseq{p_1}{p_2})$, but that could also be
  $\pseq{\nfb{\pseq{p_1}{p_2}}}{\pseq{\any\times|p_1|}{\any\times|p_2|}}$
\end{itemize}
%
It does not make sense to negate patterns which always succeed,
i.e., option or repetition.

Things that appear in the wild
\begin{itemize}
\item
\begin{verbatim}
(~T(Brace) *
  (((T(Symbol) / T(Dot)) * T(Brace)) /
   (!(T(Brace) / T(TripleColon))))++)
\end{verbatim}
\item \texttt{((In(Top) * T(File)[Class]) / T(Directory)[Class])}
\item \texttt{(!(T(Brace) / T(TripleColon)))}
\item \texttt{(In(Top) / In(ClassBody) / In(Block))}
\item
\begin{verbatim}
(T(Plus) / T(Minus) / T(Mult) / T(Div)) << T(Expression)
\end{verbatim}
\end{itemize}

\section{Term Rewriting}


\section*{TODO}

\begin{itemize}
\item Top-down vs. Bottom-up
\item Regex matching (requires carrying data)
\item Well-formedness
\item Symbol tables?
\end{itemize}

\section*{Quiz}

\begin{verbatim}
((T(Foo) * T(Bar)) << Any[Id]) >>
  [](Match& _) { return _(Id); }

(foo a) (bar b) --> a
\end{verbatim}

\begin{verbatim}
(In(Foo) << Any[Id]) >>
  [](Match& _) { return _(Id); }

(foo a) (bar b) --> Segmentation fault
\end{verbatim}

\begin{verbatim}
((!In(Bar)) * T(Baz)) >>
  [](Match& _) { return NodeDef::create(Fr0b); }

(foo baz) --> fr0b
\end{verbatim}

\end{document}
