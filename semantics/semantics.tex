\documentclass{article}

\usepackage{amsmath, amssymb}
\usepackage[usenames,dvipsnames]{xcolor}

\newcommand{\RED}[1]{\textcolor{red}{#1}}
\newcommand{\TODO}[1]{\RED{[TODO: #1]}}

\newcommand{\rulename}{\textsc}
\newcommand{\rn}{\rulename}

\newcommand{\irule}[3]{\begin{array}{l}{~\small\mbox{(\rulename{#1})}}\\\;\frac{\begin{array}{c}#2\end{array}}{\begin{array}{l}#3\end{array}}\end{array}}
%\newcommand{\irule}[3]{\frac{\begin{array}{c}#2\end{array}}{\begin{array}{l}#3\end{array}}{~\small\mbox{(\rulename{#1})}}}

\newcommand{\labelFont}{\texttt}
\newcommand{\cursorColor}{LimeGreen}

\newcommand{\lbl}{\ensuremath{\mathit{lbl}}}
\newcommand{\lbls}{\ensuremath{\mathit{lbls}}}
\newcommand{\Top}{\ensuremath{\labelFont{Top}}}
\newcommand{\Group}{\ensuremath{\labelFont{Group}}}
\newcommand{\Invalid}{\ensuremath{\labelFont{Invalid}}}
\newcommand{\Unclosed}{\ensuremath{\labelFont{Unclosed}}}

\newcommand{\tm}{\ensuremath{\mathtt{tm}}}
\newcommand{\tms}{\ensuremath{\mathtt{tms}}}

\newcommand{\Tm}{\ensuremath{\check{\tm}}}
\newcommand{\Tms}{\ensuremath{\check{\tms}}}

\newcommand{\Tmc}{\ensuremath{\overset{ \textcolor{\cursorColor}{\bowtie}}{\tm}}}
\newcommand{\Tmcb}{\ensuremath{\overset{{\bowtie}}{\tm}}}
\newcommand{\Tmcs}{\ensuremath{\overset{\textcolor{\cursorColor}{\bowtie}}{\tms}}}

%% Actions
\newcommand{\action}{\ensuremath{\alpha}}
\newcommand{\add}[1]{\ensuremath{\texttt{add}~#1}}
\newcommand{\push}[1]{\ensuremath{\texttt{push}~#1}}
\newcommand{\pop}[1]{\ensuremath{\texttt{pop}~#1}}
\newcommand{\trypop}[1]{\ensuremath{\texttt{trypop}~#1}}
\newcommand{\seq}[1]{\ensuremath{\texttt{seq}~#1}}
\newcommand{\term}[1]{\ensuremath{\texttt{term}~#1}}
\newcommand{\invalid}{\ensuremath{\texttt{invalid}}}
\newcommand{\unclosed}{\ensuremath{\texttt{unclosed}}}
\newcommand{\done}{\ensuremath{\texttt{done}}}

%% Cursors and matching
\newcommand{\cursor}{\ensuremath{\downarrow}}
\newcommand{\mstart}{\ensuremath{\textcolor{\cursorColor}{\rhd}}}
\newcommand{\mend}{\ensuremath{\textcolor{\cursorColor}{\lhd}}}

\newcommand{\bindings}{\ensuremath{\mathcal{M}}}
\newcommand{\nobindings}{\ensuremath{\emptyset}}
\newcommand{\extend}[2]{\ensuremath{#1\overset{\rightarrow}{\cup}#2}}

\newcommand{\select}[1]{\mstart\colorbox{\cursorColor}{$#1$}\mend}

\newcommand{\steps}[1]{\ensuremath{\xrightarrow{#1}}}
\newcommand{\matches}[4]{\ensuremath{#1 \vdash #2 \Rightarrow #3 ~|~ #4}}
\newcommand{\xmatches}[4]{\ensuremath{
    \begin{array}{r@{\hspace{4pt}}c@{\hspace{4pt}}l}%
      #1 & \vdash & #2 \Rightarrow\\
         &        & #3 ~|~ #4
    \end{array}}}

\newcommand{\matchesm}[5]{\ensuremath{#1 \vdash #2 : #3 \Rightarrow #4 ~|~ #5}}
\newcommand{\xmatchesm}[5]{\ensuremath{
    \begin{array}{r@{\hspace{4pt}}c@{\hspace{2pt}}l}
      #1 & \vdash & #2 : #3\Rightarrow\\
         &        & #4 ~|~ #5
    \end{array}}}

\newcommand{\wfp}[2]{\ensuremath{#1 \vdash #2}}

%% Patterns
\newcommand{\pseq}[2]{\ensuremath{#1 \cdot #2}}
\newcommand{\por}[2]{\ensuremath{#1/#2}}
\newcommand{\pand}[2]{\ensuremath{#1\&#2}}
\newcommand{\children}[2]{\ensuremath{#1} \Downarrow #2}
\newcommand{\pnot}[1]{\ensuremath{\lnot #1}}
\newcommand{\maybe}[1]{\ensuremath{#1?}}
\newcommand{\many}[1]{\ensuremath{#1^*}}
\newcommand{\any}{\ensuremath{\text{\underline{\hspace{0.6em}}}}}
\newcommand{\none}{\ensuremath{\mathbf{none}}}
\newcommand{\bind}[2]{\ensuremath{#1@#2}}
\newcommand{\paction}[2]{\ensuremath{#1\mathop{\circ} #2}}
\newcommand{\fb}[1]{\ensuremath{\rightarrow(#1)}}
\newcommand{\nfb}[1]{\ensuremath{\not\rightarrow(#1)}}
\newcommand{\pin}[1]{\ensuremath{\mathit{In}(#1)}}
\newcommand{\pstart}{\ensuremath{\mathit{Start}}}
\newcommand{\pend}{\ensuremath{\mathit{End}}}

\newcommand{\arrayheading}[2]{\multicolumn{#1}{l}{\mbox{#2}}}

\synctex=1

\begin{document}

\section{Parsing in Trieste}

\[
  \begin{array}{rcl}
    \arrayheading{3}{Labels}\\
    \lbl  & \in & \{\Top, \Group, \Invalid, \Unclosed\}\cup \mathcal{L} \\
    \lbls & ::= & \lbl_1 .. \lbl_n\\
    \\
    \arrayheading{3}{Terms}\\
    \tm  & ::= & (\lbl~\tms) \\
    \tms & ::= & \tm ~ \tms ~|~ \epsilon \\
    \\
    \arrayheading{3}{Terms with a single cursor}\\
    \Tm  & ::= & (\lbl~\Tms)\\
    \Tms & ::= & \tm ~ \Tms ~|~ \Tm ~|~ \cursor\\
    \\
    \arrayheading{3}{Contexts (shallow)}\\
    \Tm[\bullet] & ::= & (\lbl~\Tms[\bullet])\\
    \Tms[\bullet] & ::= & \tm ~ \Tms[\bullet] ~|~ \bullet\\
    \\
    \arrayheading{3}{Actions}\\
    \action & ::= & \add{\lbl}\\
            & ~|~ & \push{\lbl}\\
            & ~|~ & \pop{\lbl}\\
            & ~|~ & \pseq{\lbl}\\
            & ~|~ & \term{\lbls}\\
            & ~|~ & \trypop{\lbl}\\
            & ~|~ & \invalid\\
            & ~|~ & \unclosed\\
            & ~|~ & \done\\
  \end{array}
\]

A term \tm{} is an $n$-ary tree where each node has a label \lbl.
%
During parsing, terms \Tm{} have a single cursor \cursor{} in them,
always ``furthest to the right'' in the tree.
%
We use $\Tm[\bullet]$ to denote a term whose right-most child is a
hole $\bullet$ that can be filled with a sequence of terms.

We use the rule \rn{ctx} to ``zoom in'' close enough to the cursor
to apply a rule. Actions \term{} and \done{} are always applied to
the whole term and are therefore excluded from being applied in a
context:


\[
\irule{ctx}{
\Tm_1 \steps{\action} \Tm_2\\
\action \notin \{\term, \done\}
}{
\Tm[\Tm_1] \steps{\action} \Tm[\Tm_2]
}
\]

The action \add{\lbl} will add a \lbl-term to a group and
advance the cursor, creating a new group and moving inside it if
the cursor is not already inside one:

\[
  \begin{array}{c}
    \irule{add-in}{}{
    (\Group~\Tms[\cursor]) \steps{\add{\lbl}} (\Group~\Tms[(\lbl) \cursor])
    }
    \\\\

    \irule{add-create}{
    \lbl' \neq \Group
    }{
    (\lbl'~\Tms[\cursor]) \steps{\add{\lbl}} (\lbl'~\Tms[(\Group~(\lbl) \cursor)])
    }
  \end{array}
\]

Pushing a label adds a term (creating a group if needed) and moves
the cursor inside it:

\[
  \begin{array}{c}
    \irule{push-in}{}{
    (\Group~\Tms[\cursor]) \steps{\push{\lbl}} (\Group~\Tms[(\lbl~\cursor)])
    }
    \\\\

    \irule{push-create}{
    \lbl' \neq \Group
    }{
    (\lbl'~\Tms[\cursor]) \steps{\push{\lbl}} (\lbl'~\Tms[(\Group~(\lbl~\cursor))])
    }
  \end{array}
\]

The action \pop{\lbl} moves the cursor out of the innermost term,
assuming its label is \lbl. If the label does not match, an
error is reported (defined below):

\[
  \begin{array}{c}
    \irule{pop-ok}{
    (\lbl'~\Tms[(\lbl~\Tms'[\cursor])]) \steps{\trypop{\lbl}} \Tm
    }{
    (\lbl'~\Tms[(\lbl~\Tms'[\cursor])]) \steps{\pop{\lbl}} \Tm
    }
    \\\\

    \irule{pop-fail}{
    \lbl'' \neq \lbl\\
    (\lbl''~\Tms'[\cursor]) \steps{\invalid} \Tm
    }{
    (\lbl'~\Tms[(\lbl''~\Tms'[\cursor])]) \steps{\pop{\lbl}}
    (\lbl'~\Tms[\Tm])
    }
  \end{array}
\]

Popping is done via an auxiliary action \trypop{\lbl} which does
nothing on a label mismatch:

\[
  \begin{array}{c}
    \irule{trypop-ok}{}{
    (\lbl'~\Tms[(\lbl~\Tms'[\cursor])]) \steps{\trypop{\lbl}}
    (\lbl'~\Tms[(\lbl~\Tms'[\epsilon])~\cursor])
    }
    \\\\
    \irule{trypop-fail}{
    \lbl'' \neq \lbl
    }{
    (\lbl'~\Tms[(\lbl''~\Tms'[\cursor])]) \steps{\trypop{\lbl}}
    (\lbl'~\Tms[(\lbl''~\Tms'[\cursor])])
    }
  \end{array}
\]

Errors are reported by adding a term with the label \Invalid. If
the cursor is already next to an \Invalid-term, the extent of
that error is extended (currently just modeled as a no-op) rather
than adding another \Invalid-term:

\[
  \begin{array}{c}
    \irule{invalid-extend}{}{
    (\lbl~\Tms[(\Invalid)~\cursor]) \steps{\invalid}
    (\lbl~\Tms[(\Invalid)~\cursor])
    }
    \\\\

    \irule{invalid-empty}{
    (\lbl~\cursor) \steps{\add{\Invalid}} \Tm
    }{
    (\lbl~\cursor) \steps{\invalid} \Tm
    }
    \\\\

    \irule{invalid-non-empty}{
    \lbl' \neq \Invalid\\
    (\lbl~\Tms[(\lbl'~\Tms') \cursor]) \steps{\add{\Invalid}} \Tm
    }{
    (\lbl~\Tms[(\lbl'~\Tms') \cursor]) \steps{\invalid} \Tm
    }
  \end{array}
\]

The action \seq{\lbl} finishes the current group and makes it a
child of a \lbl-term, creating that term if it is not the parent
of the current group. Performing the \seq{}-action when not in a
group is an error:

\[
  \begin{array}{c}
    \irule{seq-in}{}{
    (\lbl~\Tms[(\Group~\Tms'[\cursor])]) \steps{\seq{\lbl}}
    (\lbl~\Tms[(\Group~\Tms'[\epsilon])~\cursor])
    }\\\\
    \irule{seq-create}{
    \lbl' \neq \lbl
    }{
    (\lbl'~\Tms[(\Group~\Tms'[\cursor])]) \steps{\seq{\lbl}}
    (\lbl'~\Tms[(\lbl~(\Group~\Tms'[\epsilon])~\cursor)])
    }\\\\
    \irule{seq-fail}{
    \lbl' \neq \Group\\
    (\lbl'~\Tms[\cursor]) \steps{\invalid} \Tm{}
    }{
    (\lbl'~\Tms[\cursor]) \steps{\seq{\lbl}} \Tm{}
    }\\\\
  \end{array}
\]

The action \term{\lbls} finishes the current group (if any) and
tries to move out of enclosing terms in the order of the labels in
\lbls, ignoring any non-matching labels. Note that this rule may
use the \rn{ctx} rule to find the right level for popping.

\[
  \begin{array}{c}
    \irule{term}{
    \Tm \steps{\trypop{\Group}} \Tm_0\\
    \forall~i\in[1..n]. \Tm_{i-1} \steps{\trypop{\lbl_i}} \Tm_i
%    \lbl_2(\Tms_2[\lbl_3(\Tms_3[\cursor])]) \steps{\trypop{\Group}} \Tm\\
%    \lbl_1(\Tms_1[\Tm]) \steps{\trypop{\lbl}} \Tm'
    }{
    \Tm \steps{\term{\lbl_1..\lbl_n}} \Tm_n
%    \lbl_1(\Tms_1[\lbl_2(\Tms_2[\lbl_3(\Tms_3[\cursor])])]) \steps{\term{\lbl}}
%    \Tm'
    }
  \end{array}
\]

Finally, the \done{} action finishes the final group (if any) and
closes the top-most term, which must have label \Top{} (As an aside,
note that we can't use \trypop{\Group} as \trypop{} assumes that
the cursor is at least at depth 2, which is not true when the
cursor a direct child of the top term). Note that the resulting
term is a term without a cursor.

\[
  \begin{array}{c}
    \irule{done}{}{
    (\Top~\Tms[\cursor]) \steps{\done} (\Top~\Tms[\epsilon])
    }
    \\\\
    \irule{done-group}{}{
    (\Top~\Tms[(\Group~\Tms'[\cursor])]) \steps{\done} (\Top~\Tms[(\Group~\Tms'[\epsilon])])
    }
  \end{array}
\]

If the cursor is \emph{not} a direct child of the top node (or in
a group that is a direct child of the top node), parsing has
terminated prematurely and we add \Unclosed{} terms along the path
to the top until we can finish the term:

\[
  \begin{array}{c}
    \irule{done-unclosed}{
    \lbl \neq \Group\\
    (\Top~\Tms[(\lbl~\Tms')]) \steps{\unclosed} \tm\\
    }{
    (\Top~\Tms[(\lbl~\Tms')]) \steps{\done} \tm
    }
    \\\\
    \irule{unclosed-top}{}{
    (\Top~\Tms[\cursor]) \steps{\unclosed} \Top(\Tms[(\Unclosed)])
    }
    \\\\
    \irule{unclosed-step}{
    \Tm \steps{\unclosed} \Tm'\\
    \Tm' \steps{\unclosed} \tm
    }{
    \Tm \steps{\unclosed} \tm
    }
    \\\\
    \irule{unclosed-add}{
    \lbl' \neq \Group
    }{
    (\lbl~\Tms[(\lbl'~\Tms'[\cursor])]) \steps{\unclosed}\\
    (\lbl~\Tms[(\lbl'~\Tms'[(\Unclosed)]) \cursor])
    }
    \\\\
    \irule{unclosed-group}{}{
    (\lbl~\Tms[(\lbl'~\Tms'[(\Group~\Tms''[\cursor])])]) \steps{\unclosed}\\
    (\lbl~\Tms[(\lbl'~\Tms'[(\Group~\Tms''[\epsilon]) ~ (\Unclosed)]) \cursor])
    }
  \end{array}
\]

\section{Pattern Matching}

\[
  \begin{array}{rcl}
    \arrayheading{3}{Terms with a sequence being matched}\\
    \Tmc & ::= & (\lbl~\Tmcs) ~|~ (\lbl~\tms~\select{\tms}~\tms)\\
    \Tmcs & ::= & \Tmc ~ \tms ~|~ \tm ~ \Tmcs\\
    \\
    \arrayheading{3}{Contexts (shallow)}\\
    \Tmc[\bullet] & ::= & (\lbl~\Tmcs[\bullet])\\
    \Tmcs[\bullet] & ::= & \bullet ~ \tms ~|~ \tm ~ \Tmcs[\bullet]\\
    \\
    \arrayheading{3}{Bindings}\\
    x, y      & \in & \mathcal{X}\\
    \bindings & \in & \mathcal{X} \mapsto \tms\\
    \\
    \multicolumn{3}{l}{
    \begin{array}{crll}
      \arrayheading{4}{Patterns}\\
      p & ::= & \lbl & \text{a term with label $\lbl$}\\
        & ~|~ & \pseq{p}{p} & \text{sequence}\\
        & ~|~ & \por{p}{p} & \text{choice}\\
        & ~|~ & \children{p}{p} & \text{with children}\\
        & ~|~ & \pnot{p} & \text{negation}\\
        & ~|~ & \maybe{p} & \text{option}\\
        & ~|~ & \many{p} & \text{repetition}\\
        & ~|~ & \any{} & \text{any term}\\
        & ~|~ & \bind{p}{x} & \text{bind}\\
        & ~|~ & \paction{p}{f} & \text{action}\\
        & ~|~ & \fb{p} & \text{followed by}\\
        & ~|~ & \nfb{p} & \text{not followed by}\\
        & ~|~ & \pin{\lbl} & \text{appears as child of}\\
        & ~|~ & \pstart{} & \text{before all children}\\
        & ~|~ & \pend{} & \text{after all children}\\
    \end{array}
    }\\
  \end{array}
\]

During matching we are selecting a sequence of sibling terms. A
term \Tmc{} is a term where one such sequence has been selected.
We represent the subterm whose children are being matched as
$(\lbl~\tms_{pre}~\select{\tms}~\tms_{post})$: a $\lbl$ term
where some subsequence $\tms$ of its children has been selected,
$\tms_{pre}$ being the terms before the match and $\tms_{post}$
the terms after the match. Matching commences by looking at terms
in $\tms_{post}$ and moving them into the matched sequence, or
equivalently, advancing the cursor $\mend$. Note that the coloring
has no semantic meaning.

The result of matching, apart from moving the cursor $\mend$, is a
set of bindings $\bindings$ which maps variables to sequences of
terms.
%
If the same variable name is used more than once, the later
binding is preferred. We write $\extend{\bindings_1}{\bindings_2}$
to mean the union of $\bindings_1$ and $\bindings_2$ where
bindings from $\bindings_2$ override overlapping bindings from
$\bindings_1$:

\[
    \extend{\bindings_1}{\bindings_2} = \bindings_2\cup \{x\mapsto \bindings_1(x) ~|~ x \in (\mathbf{dom}(\bindings_1)\setminus\mathbf{dom}(\bindings_2))\}
\]

The pattern matching rule takes the shape
$\matches{p}{\Tmc_1}{\Tmc_2}{\bindings}$, where we start from
$\Tmc_1$ and match $p$, (possibly) extending the selection
resulting in $\Tmc_2$ and the bindings $\bindings$.

Throughout, we use $\lbl_\pi$ as the label of the parent of the
nodes we are matching on.
%
Patterns $\bind{p}{x}$ which introduce a binding remembers the
terms that were matched in the resulting binding set:

\[
  \begin{array}{c}
    \irule{match-bind}{
    \matches{p}{(\lbl_\pi~\tms_{pre}~\select{\tms}~\tms_{post})}
               {(\lbl_\pi~\tms_{pre}~\select{\tms~\tms'}~\tms'_{post})}{\bindings}
    }{
    \xmatches{\bind{p}{x}}
    {(\lbl_\pi~\tms_{pre}~\select{\tms}~\tms_{post})}
    {(\lbl_\pi~\tms_{pre}~\select{\tms~\tms'}~\tms'_{post})}{\extend{\bindings} \{x\mapsto\tms'\}}
    }
  \end{array}
\]

% Patterns match on labels $\lbl$ (with $\any$ matching any label),
% and can be combined in several ways:

% \begin{itemize}
% \item $\pseq{p_1}{p_2}$     --- $p_1$ followed by $p_2$
% \item $\por{p_1}{p_2}$      --- $p_1$ or $p_2$
% \item $\children{p_1}{p_2}$ --- $p_1$ with children matching $p_2$
% \item $\pnot{p}$            --- not $p$
% \item $\maybe{p}$           --- optionally $p$
% \item $\many{p}$            --- zero or more $p$
% \end{itemize}

% We can bind the result of matching a subpattern to a name with
% the pattern $\bind{p}{x}$. There are also a number of patterns
% which do not advance the cursor:

% \begin{itemize}
% \item $\fb{p}$     --- followed by $p$
% \item $\nfb{p}$    --- not followed by $p$
% \item $\pin{\lbl}$ --- inside a node with label $\lbl$
% \item $\pstart{}$  --- before all children of the current term
% \item $\pend{}$    --- after all children of the current term
% \end{itemize}

\pstart{} and \pend{} match the very start and the very end
respectively of the full sequence of children:

\[
  \begin{array}{c}
    \irule{match-start}{}{
    \matches{\pstart}
    {(\lbl_\pi~\mstart\mend~\tms_{post})}
    {(\lbl_\pi~\mstart\mend~\tms_{post})}{\nobindings}
    }
    \\\\
    \irule{match-end}{}{
    \xmatches{\pend}
    {(\lbl_\pi~\tms_{pre}~\select{\tms})}
    {(\lbl_\pi~\tms_{pre}~\select{\tms})}{\nobindings}
    }
  \end{array}
\]

$\pin{\lbl}$ succeeds if we are matching directly inside a $\lbl$
term:

\[
  \begin{array}{c}
    \irule{match-in}{}{
    \xmatches{\pin{\lbl_\pi}}
    {(\lbl_\pi~\tms_{pre}~\select{\tms}~\tms_{post})}
    {(\lbl_\pi~\tms_{pre}~\select{\tms}~\tms_{post})}{\nobindings}
    }
  \end{array}
\]

The lookahead patterns $\fb{p}$ and $\nfb{p}$ tries the pattern
$p$, but does not advance the cursor nor remember bindings.

\[
  \begin{array}{c}
    \irule{match-followed-by}{
    \matches{p}{(\lbl_\pi~\tms_{pre}~\select{\tms}~\tms_{post})}{\Tmc}{\bindings}
    }{
    \xmatches{\fb{p}}
    {(\lbl_\pi~\tms_{pre}~\select{\tms}~\tms_{post})}
    {(\lbl_\pi~\tms_{pre}~\select{\tms}~\tms_{post})}{\nobindings}
    }
    \\\\
    \irule{match-not-followed-by}{
    \lnot(\matches{p}{(\lbl_\pi~\tms_{pre}~\select{\tms}~\tms_{post})}{\Tmc}){\bindings}
    }{
    \xmatches{\nfb{p}}
    {(\lbl_\pi~\tms_{pre}~\select{\tms}~\tms_{post})}
    {(\lbl_\pi~\tms_{pre}~\select{\tms}~\tms_{post})}{\nobindings}
    }
  \end{array}
\]

Matching on a label $\lbl$ succeeds if it is the next label.
Matching on a wild-card always succeeds as long as there is a term
to match on:

\[
  \begin{array}{c}
    \irule{match-label}{}{
    \xmatches{\lbl}
    {(\lbl_\pi~\tms_{pre}~\select{\tms}~(\lbl~\tms')~\tms_{post})}
    {(\lbl_\pi~\tms_{pre}~\select{\tms~(\lbl~\tms')}~\tms_{post})}{\nobindings}
    }
    \\\\
    \irule{match-any}{}{
    \xmatches{\any}
    {(\lbl_\pi~\tms_{pre}~\select{\tms}~(\lbl~\tms')~\tms_{post})}
    {(\lbl_\pi~\tms_{pre}~\select{\tms~(\lbl~\tms')}~\tms_{post})}{\nobindings}
    }
  \end{array}
\]

Patterns in sequence are matched left to right, with later
bindings being preferred over earlier:

\[
  \begin{array}{c}
    \irule{match-sequence}{
    \matches{p_1}{(\lbl_\pi~\tms_{pre}~\select{\tms}~\tms_{post})}{\Tmc_1}{\bindings_1}\\
    \matches{p_2}{\Tmc_1}{\Tmc_2}{\bindings_2}\\
    }{
    \matches{\pseq{p_1}{p_2}}
    {(\lbl_\pi~\tms_{pre}~\select{\tms}~\tms_{post})}
    {\Tmc_2}{\extend{\bindings_1}{\bindings_2}}
    }
  \end{array}
\]

Alternative patterns $\por{p_1}{p_2}$ picks the first of the two
patterns that matches [Could not be zoomed in?]:

\[
  \begin{array}{c}
    \irule{match-or-l}{
    \matches{p_1}{(\lbl_\pi~\tms_{pre}~\select{\tms}~\tms_{post})}{\Tmc}{\bindings}
    }{
    \matches{\por{p_1}{p_2}}
    {(\lbl_\pi~\tms_{pre}~\select{\tms}~\tms_{post})}
    {\Tmc}{\bindings}
    }
    \\\\
    \irule{match-or-r}{
    \lnot(\matches{p_1}{(\lbl_\pi~\tms_{pre}~\select{\tms}~\tms_{post})}{\Tmc_1}{\bindings_1})\\
    \matches{p_2}{(\lbl_\pi~\tms_{pre}~\select{\tms}~\tms_{post})}{\Tmc_2}{\bindings_2}
    }{
    \matches{\por{p_1}{p_2}}
    {(\lbl_\pi~\tms_{pre}~\select{\tms}~\tms_{post})}
    {\Tmc_2}{\bindings_2}
    }
  \end{array}
\]

The rule for matching children $\children{p_1}{p_2}$ is probably
the most complicated. First, the pattern $p_1$ matches normally
and defines the movement of the cursor to include $\tms_1$.
Additionally, we extract the first term $(\lbl~\tms_{11})$ inside
which we match $p_2$. We transfer the bindings from the inner
match to the final results, preferring these bindings to ones from
the outer match.
%
Note that $p_1$ must match at least one term.

\[
  \begin{array}{c}
    \irule{match-children}{
    \matches{p_1}{(\lbl_\pi~\tms_{pre}~\select{\tms}~\tms_{post})}
                 {(\lbl_\pi~\tms_{pre}~\select{\tms~\tms_1}~\tms'_{post})}{\bindings_1}\\
    \tms_1 = (\lbl~\tms_{11})~\tms'_1\\
    \matches{p_2}{(\lbl~\mstart\mend~\tms_{11})}{\Tmc}{\bindings_2}
    }{
    \xmatches{\children{p_1}{p_2}}
    {(\lbl_\pi~\tms_{pre}~\select{\tms}~\tms_{post})}
    {(\lbl_\pi~\tms_{pre}~\select{\tms~\tms_1}~\tms'_{post})}
    {\extend{\bindings_1}{\bindings_2}}
    }
  \end{array}
\]

The negation of a pattern $\pnot{p}$ matches the subsequent term
if $p$ does \emph{not} match. Note that this means that the next
term is consumed regardless of whether the pattern $p$ consumes
zero or more than one term:

\[
  \begin{array}{c}
    \irule{match-not}{
    \lnot(\matches{p}{(\lbl_\pi~\tms_{pre}~\select{\tms}~(\lbl~\tms')~\tms_{post})}{\Tmc}{\bindings})
    }{
    \xmatches{\pnot{p}}
    {(\lbl_\pi~\tms_{pre}~\select{\tms}~(\lbl~\tms')~\tms_{post})}
    {(\lbl_\pi~\tms_{pre}~\select{\tms~(\lbl~\tms')}~\tms_{post})}{\nobindings}
    }
  \end{array}
\]

Optional matches $\maybe{p}$ always succeeds, but matches $p$ if
possible:

\[
  \begin{array}{c}
    \irule{match-option-yes}{
    \matches{p}{(\lbl_\pi~\tms_{pre}~\select{\tms}~\tms_{post})}{\Tmc}{\bindings}
    }{
    \matches{\maybe{p}}
    {(\lbl_\pi~\tms_{pre}~\select{\tms}~\tms_{post})}
    {\Tmc}{\bindings}
    }
    \\
    \\
    \irule{match-option-no}{
    \lnot(\matches{p}{(\lbl_\pi~\tms_{pre}~\select{\tms}~\tms_{post})}{\Tmc}{\bindings})
    }{
    \xmatches{\maybe{p}}
    {(\lbl_\pi~\tms_{pre}~\select{\tms}~\tms_{post})}
    {(\lbl_\pi~\tms_{pre}~\select{\tms}~\tms_{post})}{\nobindings}
    }
  \end{array}
\]

Repetition of a pattern $\many{p}$ will greedily match $p$ as many
times as possible, preferring later bindings to earlier:

\[
  \begin{array}{c}
    \irule{match-many-more}{
    \matches{p}{(\lbl_\pi~\tms_{pre}~\select{\tms}~\tms_{post})}{\Tmc_1}{\bindings_1}\\
    \matches{\many{p}}{\Tmc_1}{\Tmc_2}{\bindings_2}
    }{
    \matches{\many{p}}
    {(\lbl_\pi~\tms_{pre}~\select{\tms}~\tms_{post})}
    {\Tmc_2}{\extend{\bindings_1}{\bindings_2}}
    }
    \\\\
    \irule{match-many-done}{
    \lnot(\matches{p}{(\lbl_\pi~\tms_{pre}~\select{\tms}~\tms_{post})}{\Tmc}{\bindings})
    }{
    \xmatches{\many{p}}
    {(\lbl_\pi~\tms_{pre}~\select{\tms}~\tms_{post})}
    {(\lbl_\pi~\tms_{pre}~\select{\tms}~\tms_{post})}{\nobindings}
    }
  \end{array}
\]

An action pattern $\paction{p}{f}$ comes equipped with a function
$f : \tms \mapsto \mathbf{bool}$ which must return $\mathbf{true}$
for the matched pattern:

\[
  \begin{array}{c}
    \irule{match-action}{
    \matches{p}{(\lbl_\pi~\tms_{pre}~\select{\tms}~\tms_{post})}
               {(\lbl_\pi~\tms_{pre}~\select{\tms~\tms'}~\tms'_{post})}{\bindings}\\
    f(\tms') = \mathbf{true}
    }{
    \xmatches{\paction{p}{f}}
    {(\lbl_\pi~\tms_{pre}~\select{\tms}~\tms_{post})}
    {(\lbl_\pi~\tms_{pre}~\select{\tms~\tms'}~\tms'_{post})}{\bindings}
    }
  \end{array}
\]


As with parsing, we use contexts to ``zoom in'' until we can apply
a matching rule:

\[
  \begin{array}{c}
    \irule{match-ctx}{
    \matches{p}{\Tmc_1}{\Tmc_2}{\bindings}
    }{
    \matches{p}{\Tmc[\Tmc_1]}{\Tmc[\Tmc_2]}{\bindings}
    }
  \end{array}
\]

\section{New Pattern Semantics}

\[
  \begin{array}{rcl}
    \arrayheading{3}{Terms with a sequence being matched}\\
    \Tmc & ::= & (\lbl~\Tmcs) ~|~ (\lbl~\tms~\select{\tms}~\tms)\\
    \Tmcs & ::= & \Tmc ~ \tms ~|~ \tm ~ \Tmcs\\
    \\
    \arrayheading{3}{Contexts (shallow)}\\
    \Tmc[\bullet] & ::= & (\lbl~\Tmcs[\bullet])\\
    \Tmcs[\bullet] & ::= & \bullet ~ \tms ~|~ \tm ~ \Tmcs[\bullet]\\
    \\
    \arrayheading{3}{Bindings}\\
    x, y      & \in & \mathcal{X}\\
    \bindings & \in & \mathcal{X} \mapsto \tms\\
    \\
    \multicolumn{3}{l}{
    \begin{array}{crll}
      \arrayheading{4}{Patterns}\\
      \phi & ::= & \fb{p} & \text{followed by}\\
           & ~|~ & \nfb{p} & \text{not followed by}\\
           & ~|~ & \pin{\lbl} & \text{appears as child of}\\
           & ~|~ & \pstart{} & \text{before all children}\\
           & ~|~ & \pend{} & \text{after all children}\\
      \\
      s & ::= & \lbl & \text{a term with label $\lbl$}\\
        & ~|~ & !\lbl & \text{a term with a label different from $\lbl$}\\
        & ~|~ & \any{} & \text{any single term}\\
        & ~|~ & \none{} & \text{no single term}\\
        & ~|~ & \children{s}{p} & \text{$s$ with children $p$}\\
        & ~|~ & \por{s}{s} & \text{choice}\\
        & ~|~ & \pand{s}{s} & \text{conjunction}\\
        & ~|~ & \pnot{s} & \text{negation}\\
      \\
      p & ::= & \phi & \text{predicate}\\
        & ~|~ & s & \text{single term pattern}\\
        & ~|~ & \pseq{p}{p} & \text{sequence}\\
        & ~|~ & \maybe{p} & \text{option}\\
        & ~|~ & \many{p} & \text{repetition}\\
        & ~|~ & \bind{p}{x} & \text{bind}\\
        & ~|~ & \paction{p}{f} & \text{action}\\
    \end{array}
    }
  \end{array}
\]
%
The semantics presented here are different in several ways. First,
it divides the patterns into different syntactic categories
depending on whether they are predicates, match a single term, or
match (possibly) multiple terms. Second, the pattern matching
semantics results in a multiplicity $m$ (defined in the next
section), denoting if the sequence matched contains zero, one or
an unknown number $\omega$ of terms.
%
The purpose of the multiplicity is to know how a bound sequence of
terms can be used: In order to extract or provide children for a
given variable, the multiplicity $1$ is required.

Importantly, this new design has reasonable semantics for negation
and binding but still allows, \emph{e.g.}, the following pattern:

\[
\many{(\pnot{(\por{(\children{\textit{foo}}{p_1})}{(\children{\textit{bar}}{p_2})})})}
\]
%
% The reason \any{} is not in $s$ even though it matches a single
% term is that it allows us to keep $s$ closed under negation if we
% think of it as a function:
%
The reason for the \none{} pattern is that it allows single terms
$s$ to be closed under negation if we think of it as a function:

\[
  \begin{array}{lcl}
    \pnot{\lbl}              & \equiv & !\lbl\\
    \pnot{!\lbl}             & \equiv & \lbl\\
    \pnot{\any}              & \equiv & \none{}\\
    \pnot{\none}             & \equiv & \any{}\\
    \pnot{(\children{s}{p})} & \equiv & \por{(\pnot s)}{(\children{s}{(\nfb{p})})}\\
    \pnot{(\por{s_1}{s_2})}  & \equiv & \pand{\pnot s_1}{\pnot s_2}\\
    \pnot{(\pand{s_1}{s_2})} & \equiv & \por{\pnot s_1}{\pnot s_2}\\
    \pnot(\pnot{s})          & \equiv & s\\
  \end{array}
\]
%
For single patterns, we have the property that when matching on
non-empty sequences, $\pnot{p}$ matches if and only if $p$ does
not match.
%
Note that we have negation of predicates in the form of
$\nfb{\phi}$ with a similar property for general sequences.
%
Negation of the remaining patterns in $p$ doesn't
make sense for the following reasons:

\begin{itemize}
\item $\pnot{(\pseq{p}{p})}$ -- unclear how many terms should be
  matched on success (for the answer ``zero'', we have
  $\nfb{\pseq{p}{p}}$)
\item $\pnot{(\maybe{p})}$ -- would always fail ($\maybe{p}$ always
  succeeds)
\item $\pnot{(\many{p})}$ -- would always fail ($\many{p}$ always
  succeeds)
\item $\pnot{(\bind{x}{p})}$ -- why \emph{not} bind a variable?
\item $\pnot{(\paction{p}{f})}$ -- function can be negated in
  object language:
  $\paction{p}{(\lambda \tms .~ \texttt{not} (f~\tms))}$)
\end{itemize}
%
% \noindent
% We lift each of these operation to bindings $\bindings$:
%
% \[
%   m \odot \bindings = \{x \mapsto (m \odot m')~\tms ~|~ (x \mapsto m'~\tms) \in \bindings\}
% \]
%
The pattern matching rule takes the shape
$\matches{p}{\Tmc_1}{\Tmc_2}{\bindings}$, where we start from
$\Tmc_1$ and match $p$, (possibly) extending the selection
resulting in $\Tmc_2$ and the bindings $\bindings$.

Throughout, we use $\lbl_\pi$ as the label of the parent of the
nodes we are matching on.
%
Patterns $\bind{p}{x}$ introduce a binding and remembers the terms
that were matched in the resulting binding set, \RED{together with the
multiplicity of the pattern $p$}:

\[
  \begin{array}{c}
    \irule{match-bind}{
    \xmatches{p}{(\lbl_\pi~\tms_{pre}~\select{\tms}~\tms_{post})}
                {(\lbl_\pi~\tms_{pre}~\select{\tms~\tms'}~\tms'_{post})}{\bindings}
    }{
    \xmatches{\bind{p}{x}}
    {(\lbl_\pi~\tms_{pre}~\select{\tms}~\tms_{post})}
    {(\lbl_\pi~\tms_{pre}~\select{\tms~\tms'}~\tms'_{post})}{\extend{\bindings} \{x\mapsto \tms'\}}
    }
  \end{array}
\]
%
\pstart{} and \pend{} match the very start and the very end
respectively of the full sequence of children:

\[
  \begin{array}{c}
    \irule{match-start}{}{
    \matches{\pstart}
    {(\lbl_\pi~\mstart\mend~\tms_{post})}
    {(\lbl_\pi~\mstart\mend~\tms_{post})}{\nobindings}
    }
    \\\\
    \irule{match-end}{}{
    \xmatches{\pend}
    {(\lbl_\pi~\tms_{pre}~\select{\tms})}
    {(\lbl_\pi~\tms_{pre}~\select{\tms})}{\nobindings}
    }
  \end{array}
\]
%
$\pin{\lbl}$ succeeds if we are matching directly inside a $\lbl$
term:

\[
  \begin{array}{c}
    \irule{match-in}{}{
    \xmatches{\pin{\lbl_\pi}}
    {(\lbl_\pi~\tms_{pre}~\select{\tms}~\tms_{post})}
    {(\lbl_\pi~\tms_{pre}~\select{\tms}~\tms_{post})}{\nobindings}
    }
  \end{array}
\]
%
The lookahead patterns $\fb{p}$ and $\nfb{p}$ tries the pattern
$p$, but does not advance the cursor nor remember bindings.

\[
  \begin{array}{c}
    \irule{match-followed-by}{
    \matches{p}{(\lbl_\pi~\tms_{pre}~\select{\tms}~\tms_{post})}{\Tmc}{\bindings}
    }{
    \xmatches{\fb{p}}
    {(\lbl_\pi~\tms_{pre}~\select{\tms}~\tms_{post})}
    {(\lbl_\pi~\tms_{pre}~\select{\tms}~\tms_{post})}{\nobindings}
    }
    \\\\
    \irule{match-not-followed-by}{
    \lnot(\matches{p}{(\lbl_\pi~\tms_{pre}~\select{\tms}~\tms_{post})}{\Tmc}{\bindings})
    }{
    \xmatches{\nfb{p}}
    {(\lbl_\pi~\tms_{pre}~\select{\tms}~\tms_{post})}
    {(\lbl_\pi~\tms_{pre}~\select{\tms}~\tms_{post})}{\nobindings}
    }
  \end{array}
\]
%
Matching on a label $\lbl$ succeeds if it is the next label.
Matching on a wild-card \any{} always succeeds as long as there is
a term to match on.

\[
  \begin{array}{c}
    \irule{match-label}{}{
    \xmatches{\lbl}
    {(\lbl_\pi~\tms_{pre}~\select{\tms}~(\lbl~\tms')~\tms_{post})}
    {(\lbl_\pi~\tms_{pre}~\select{\tms~(\lbl~\tms')}~\tms_{post})}{\nobindings}
    }
    \\\\
    \irule{match-not-label}{\lbl \neq \lbl'}{
    \xmatches{!\lbl}
    {(\lbl_\pi~\tms_{pre}~\select{\tms}~(\lbl'~\tms')~\tms_{post})}
    {(\lbl_\pi~\tms_{pre}~\select{\tms~(\lbl'~\tms')}~\tms_{post})}{\nobindings}
    }
    \\\\
    \irule{match-any}{}{
    \xmatches{\any}
    {(\lbl_\pi~\tms_{pre}~\select{\tms}~(\lbl~\tms')~\tms_{post})}
    {(\lbl_\pi~\tms_{pre}~\select{\tms~(\lbl~\tms')}~\tms_{post})}{\nobindings}
    }
  \end{array}
\]
%
Matching children $\children{s}{p}$ first uses $s$ to match a
single node, and then further requires that $p$ matches its
children (we don't care about \emph{which} terms are matched
here). We transfer the bindings from the inner match to the final
results, preferring these bindings to ones from the outer match.

\[
  \begin{array}{c}
    \irule{match-children}{
    \xmatches{s}{(\lbl_\pi~\tms_{pre}~\select{\tms}~(\lbl~\tms_1)~\tms_{post})}
                 {(\lbl_\pi~\tms_{pre}~\select{\tms~(\lbl~\tms_1)}~\tms_{post})}{\bindings_1}\\
    \matches{p}{(\lbl~\mstart\mend~\tms_1)}{\Tmc}{\bindings_2}
    }{
    \xmatches{\children{s}{p}}
    {(\lbl_\pi~\tms_{pre}~\select{\tms}~(\lbl~\tms_1)~\tms_{post})}
    {(\lbl_\pi~\tms_{pre}~\select{\tms~(\lbl~\tms_1)}~\tms_{post})}
    {\extend{\bindings_1}{\bindings_2}}
    }
  \end{array}
\]
%
Choice and conjunction work as expected. Note that choice is
\emph{ordered}, meaning the first pattern is preferred if both
patterns match.

\[
  \begin{array}{c}
    \irule{match-choice-l}{
    \xmatches{s_1}{(\lbl_\pi~\tms_{pre}~\select{\tms}~(\lbl~\tms')~\tms_{post})}
                  {(\lbl_\pi~\tms_{pre}~\select{\tms~(\lbl~\tms')}~\tms_{post})}{\bindings_1}
    }{
    \xmatches{\por{s_1}{s_2}}{(\lbl_\pi~\tms_{pre}~\select{\tms}~(\lbl~\tms')~\tms_{post})}
             {(\lbl_\pi~\tms_{pre}~\select{\tms~(\lbl~\tms')}~\tms_{post})}{\bindings_1}
    }
    \\\\
    \irule{match-choice-r}{
    \lnot\left(\matches{s_1}{(\lbl_\pi~\tms_{pre}~\select{\tms}~(\lbl~\tms')~\tms_{post})}
                  {\Tmc}{\bindings_1}\right)\\
    \xmatches{s_2}{(\lbl_\pi~\tms_{pre}~\select{\tms}~(\lbl~\tms')~\tms_{post})}
                  {(\lbl_\pi~\tms_{pre}~\select{\tms~(\lbl~\tms')}~\tms_{post})}{\bindings_2}
    }{
    \xmatches{\por{s_1}{s_2}}{(\lbl_\pi~\tms_{pre}~\select{\tms}~(\lbl~\tms')~\tms_{post})}
             {(\lbl_\pi~\tms_{pre}~\select{\tms~(\lbl~\tms')}~\tms_{post})}{\bindings_2}
    }
    \\\\
    \irule{match-conj}{
    \xmatches{s_1}{(\lbl_\pi~\tms_{pre}~\select{\tms}~(\lbl~\tms')~\tms_{post})}
                  {(\lbl_\pi~\tms_{pre}~\select{\tms~(\lbl~\tms')}~\tms_{post})}{\bindings_1}\\
    \xmatches{s_2}{(\lbl_\pi~\tms_{pre}~\select{\tms}~(\lbl~\tms')~\tms_{post})}
                  {(\lbl_\pi~\tms_{pre}~\select{\tms~(\lbl~\tms')}~\tms_{post})}{\bindings_2}
    }{
    \xmatches{\pand{s_1}{s_2}}{(\lbl_\pi~\tms_{pre}~\select{\tms}~(\lbl~\tms')\tms_{post})}
             {(\lbl_\pi~\tms_{pre}~\select{\tms~(\lbl~\tms')}~\tms_{post})}{\extend{\bindings_1}{\bindings_2}}
    }
  \end{array}
\]
%
The negation of a pattern $\pnot{s}$ matches the subsequent term
if $s$ does \emph{not} match. Note that negation only consumes one
term:

\[
  \begin{array}{c}
    \irule{match-not}{
    \lnot\left(\matches{s}{(\lbl_\pi~\tms_{pre}~\select{\tms}~(\lbl~\tms')~\tms_{post})}{\Tmc}{\bindings}\right)
    }{
    \xmatches{\pnot{s}}
    {(\lbl_\pi~\tms_{pre}~\select{\tms}~(\lbl~\tms')~\tms_{post})}
    {(\lbl_\pi~\tms_{pre}~\select{\tms~(\lbl~\tms')}~\tms_{post})}{\nobindings}
    }
  \end{array}
\]
%
Patterns in sequence are matched left to right, with later
bindings being preferred over earlier:

\[
  \begin{array}{c}
    \irule{match-sequence}{
    \matches{p_1}{(\lbl_\pi~\tms_{pre}~\select{\tms}~\tms_{post})}{\Tmc_1}{\bindings_1}\\
    \matches{p_2}{\Tmc_1}{\Tmc_2}{\bindings_2}\\
    }{
    \matches{\pseq{p_1}{p_2}}
    {(\lbl_\pi~\tms_{pre}~\select{\tms}~\tms_{post})}
    {\Tmc_2}{\extend{\bindings_1}{\bindings_2}}
    }
  \end{array}
\]
%
Optional matches $\maybe{p}$ always succeeds, but matches $p$ if
possible. All bindings in $p$ get the multiplicity $\omega$ since
we do not know whether the pattern matches or not.

\[
  \begin{array}{c}
    \irule{match-option-yes}{
    \matches{p}{(\lbl_\pi~\tms_{pre}~\select{\tms}~\tms_{post})}{\Tmc}{\bindings}
    }{
    \matches{\maybe{p}}
    {(\lbl_\pi~\tms_{pre}~\select{\tms}~\tms_{post})}
    {\Tmc}{\bindings}
    }
    \\
    \\
    \irule{match-option-no}{
    \lnot\left(\matches{p}{(\lbl_\pi~\tms_{pre}~\select{\tms}~\tms_{post})}{\Tmc}{\bindings}\right)
    }{
    \xmatches{\maybe{p}}
    {(\lbl_\pi~\tms_{pre}~\select{\tms}~\tms_{post})}
    {(\lbl_\pi~\tms_{pre}~\select{\tms}~\tms_{post})}{\nobindings}
    }
  \end{array}
\]
%
Repetition of a pattern $\many{p}$ will greedily match $p$ as many
times as possible, preferring later bindings to earlier:

\[
  \begin{array}{c}
    \irule{match-many-more}{
    \matches{p}{(\lbl_\pi~\tms_{pre}~\select{\tms}~\tms_{post})}{\Tmc_1}{\bindings_1}\\
    \matches{\many{p}}{\Tmc_1}{\Tmc_2}{\bindings_2}
    }{
    \matches{\many{p}}
    {(\lbl_\pi~\tms_{pre}~\select{\tms}~\tms_{post})}
    {\Tmc_2}{\extend{\bindings_1}{\bindings_2}}
    }
    \\\\
    \irule{match-many-done}{
    \lnot\left(\matches{p}{(\lbl_\pi~\tms_{pre}~\select{\tms}~\tms_{post})}{\Tmc}{\bindings}\right)
    }{
    \xmatches{\many{p}}
    {(\lbl_\pi~\tms_{pre}~\select{\tms}~\tms_{post})}
    {(\lbl_\pi~\tms_{pre}~\select{\tms}~\tms_{post})}{\nobindings}
    }
  \end{array}
\]
%
An action pattern $\paction{p}{f}$ comes equipped with a function
$f : \tms \mapsto \mathbf{bool}$ which must return $\mathbf{true}$
for the matched pattern:

\[
  \begin{array}{c}
    \irule{match-action}{
    \matches{p}{(\lbl_\pi~\tms_{pre}~\select{\tms}~\tms_{post})}
               {(\lbl_\pi~\tms_{pre}~\select{\tms~\tms'}~\tms'_{post})}{\bindings}\\
    f(\tms') = \mathbf{true}
    }{
    \xmatches{\paction{p}{f}}
    {(\lbl_\pi~\tms_{pre}~\select{\tms}~\tms_{post})}
    {(\lbl_\pi~\tms_{pre}~\select{\tms~\tms'}~\tms'_{post})}{\bindings}
    }
  \end{array}
\]
%
As with parsing, we use contexts to ``zoom in'' until we can apply
a matching rule:

\[
  \begin{array}{c}
    \irule{match-ctx}{
    \matches{p}{\Tmc_1}{\Tmc_2}{\bindings}
    }{
    \matches{p}{\Tmc[\Tmc_1]}{\Tmc[\Tmc_2]}{\bindings}
    }
  \end{array}
\]

\subsection{Well-Formed Patterns}

\[
  \begin{array}{rcl}
    \Gamma & ::= & \Gamma, x : m ~|~ \epsilon\\
    m      & ::= & 0 ~|~ 1 ~|~ \omega
  \end{array}
\]
%
In this section we present the rules for mapping variables to
multiplicities. The well-formedness rule has the shape
$\wfp{Gamma}{p}$, where $\Gamma$ is a map from variables to their
multiplicity.

Multiplicities of patterns are calculated as $\mu(p)$:

\[
  \begin{array}{rcl}
    \mu(\phi)            & = & 0\\
    \mu(s)               & = & 1\\
    \mu(\pseq{p_1}{p_2}) & = & \mu(p_1) \oplus \mu(p_2)\\
    \mu(\maybe{p})       & = & \omega\\
    \mu(\many{p})        & = & \omega\\
    \mu(\bind{p}{x})     & = & \mu(p)\\
    \mu(\paction{p}{f})  & = & \mu(p)\\
  \end{array}
\]
%
Note that $\mu(\none{}) = 1$, which may seem strange since \none{}
never matches. This however gives us the property that
$\mu(s) = \mu(\pnot{s})$ for all $s$.

We define the following operations on multiplicities
\TODO{$\otimes$ currently isn't used}:

$
  m_1 \oplus m_2 =
  \begin{cases}
    0 & \text{if $m_1 = m_2 = 0$}\\
    1 & \text{if $m_1 = 0$ and $m_2 = 1$ or $m_1 = 1$ and $m_2 = 0$}\\
    \omega & \text{otherwise}\\
  \end{cases}
$

$
  m_1 \otimes m_2 =
  \begin{cases}
    0 & \text{if $m_1 = 0$ or $m_2 = 0$}\\
    m_1 & \text{if $m_2 = 1$}\\
    m_2 & \text{if $m_1 = 1$}\\
    \omega & \text{otherwise}\\
  \end{cases}
$

$
  m_1 \oslash m_2 =
  \begin{cases}
    0 & \text{if $m_1 = m_2 = 0$}\\
    1 & \text{if $m_1 = m_2 = 1$}\\
    \omega & \text{otherwise}\\
  \end{cases}
$

\noindent
We lift operations on multiplicities in the expected way:

\[
  m \odot \Gamma =
  \begin{cases}
    (m \odot \Gamma'), x : (m \odot m') & \text{if } \Gamma = \Gamma', x : m'\\
    \epsilon & \text{otherwise}
  \end{cases}
\]
%
We also define choice-merging of multiplicity maps, where
non-overlapping bindings get multiplicity $\omega$ and overlapping
bindings with multiplicities $m_1$ and $m_2$ get the multiplicity
$m_1 \oslash m_2$.

\[
  \Gamma_1 \oslash \Gamma_2 =
  (\omega \oslash (\Gamma_1 \setminus \Gamma_2)),
  [x : m_1 \oslash m_2 ~|~ \Gamma_1(x) = m_1 ~\land~ \Gamma_2(x) = m_2],
  (\omega \oslash (\Gamma_2 \setminus \Gamma_1))
\]
%
Here, we take subtraction $\Gamma_1 \setminus \Gamma_2$ to mean
the mappings in $\Gamma_1$ whose variables are not in $\Gamma_2$:

\[
\Gamma_1 \setminus \Gamma_2 = [x : m ~|~ \Gamma_1(x) = x ~\land~ x \notin \mathbf{dom}(\Gamma_2)]
\]
%
% \[
%   \Gamma_1 \odot \Gamma_2 =
%   \begin{cases}
%     (\Gamma'_1 \odot \Gamma'_2), x : (m_1 \odot m_2) & \text{if } \Gamma_1 = \Gamma'_1, x : m_1 \text{ and } \Gamma'_2, x : m_2\\
%     \epsilon & \text{otherwise}
%   \end{cases}
% \]
%
All the predicates are well-formed if their nested patterns are
well-formed. Any bindings in the nested patterns are discarded.

\[
  \begin{array}{c}
    \irule{wf-followed-by}{
    p \dashv \Gamma
    }{
    \fb{p} \dashv \epsilon
    }
    \quad
    \irule{wf-not-followed-by}{
    p \dashv \Gamma
    }{
    \nfb{p} \dashv \epsilon
    }
    \\\\
    \irule{wf-in}{
    }{
    \pin{\lbl} \dashv \epsilon
    }
    \quad
    \irule{wf-start}{
    }{
    \pstart \dashv \epsilon
    }
    \quad
    \irule{wf-end}{
    }{
    \pstart \dashv \epsilon
    }
  \end{array}
\]
%
The atomic single term patterns trivially have no bindings.
Negation ignores nested bindings since \pnot{s} only matches $s$
does not.
%
The children pattern disallows overlapping bindings.

\[
  \begin{array}{c}
    \irule{wf-label}{
    }{
    \lbl \dashv \epsilon
    }
    \quad
    \irule{wf-not-label}{
    }{
    !\lbl \dashv \epsilon
    }
    \\\\
    \irule{wf-any}{
    }{
    \any \dashv \epsilon
    }
    \quad
    \irule{wf-none}{
    }{
    \none \dashv \epsilon
    }
    \quad
    \irule{wf-not}{
    s \dashv \Gamma
    }{
    \pnot{s} \dashv \epsilon
    }
    \\\\
    \irule{wf-children}{
    s \dashv \Gamma_s\quad
    p \dashv \Gamma_p\\
    \mathbf{dom}(\Gamma_s) \cap \mathbf{dom}(\Gamma_p) = \emptyset
    }{
    \children{s}{p} \dashv \Gamma_s, \Gamma_p
    }
  \end{array}
\]
%
Choice and conjunction work as expected. Bindings may not overlap
for conjunctions, and \emph{must} overlap for choice. The
resulting multiplicity for bindings in a choice is $\omega$ unless
the overlapping bindings have the same multiplicity.

\[
  \begin{array}{c}
    \irule{wf-choice}{
    s_1 \dashv \Gamma_1\quad
    s_2 \dashv \Gamma_2\\
    \mathbf{dom}(\Gamma_1) = \mathbf{dom}(\Gamma_2)
    }{
    \por{s_1}{s_2} \dashv \Gamma_1 \oslash \Gamma_2
    }
    \quad
    \irule{wf-conj}{
    s_1 \dashv \Gamma_1\quad
    s_2 \dashv \Gamma_2\\
    \mathbf{dom}(\Gamma_1) \cap \mathbf{dom}(\Gamma_2) = \emptyset
    }{
    \pand{s_1}{s_2} \dashv \Gamma_1, \Gamma_2
    }
  \end{array}
\]
%
Sequences of patterns produce the union of their bindings.
Optional and repeating patterns give bindings in nested patterns
the multiplicity $\omega$, since we don't know if they consume
anything.

\[
  \begin{array}{c}
    \irule{wf-seq}{
    p_1 \dashv \Gamma_1\quad
    p_2 \dashv \Gamma_2\\
    \mathbf{dom}(\Gamma_1) \cap \mathbf{dom}(\Gamma_2) = \emptyset
    }{
    \pseq{p_1}{p_2} \dashv \Gamma_1, \Gamma_2
    }
    \quad
    \irule{wf-option}{
    p \dashv \Gamma
    }{
    \maybe{p} \dashv \omega \oplus \Gamma
    }
    \quad
    \irule{wf-many}{
    p \dashv \Gamma
    }{
    \many{p} \dashv \omega \oplus \Gamma
    }
  \end{array}
\]
%
Binding a variable gives the variable the multiplicity of the
underlying pattern. Actions are ignored.
\[
  \begin{array}{c}
    \irule{wf-bind}{
    }{
    \bind{p}{x} \dashv x : \mu(p)
    }
    \quad
    \irule{wf-action}{
    p \dashv \Gamma
    }{
    \paction{p}{f} \dashv \Gamma
    }
  \end{array}
\]

\subsection{Pushing Choice Outwards While not Botching Negation}

\[
  \begin{array}{crll}
    \arrayheading{4}{Patterns}\\
      \phi & ::= & \fb{p} & \text{followed by}\\
           & ~|~ & \pin{\lbl} & \text{appears as child of}\\
           & ~|~ & \pstart{} & \text{before all children}\\
           & ~|~ & \pend{} & \text{after all children}\\
           & ~|~ & \pnot{\phi} & \text{negation}\\
      \\
      s & ::= & \lbls & \text{a term with label in $\lbls$}\\
        & ~|~ & !\lbls & \text{a term with a label not in $\lbls$}\\
        & ~|~ & \any{} & \text{any single term}\\
      \\
      p & ::= & \phi & \text{predicate}\\
        & ~|~ & s & \text{single term pattern}\\
        & ~|~ & \por{p}{p} & \text{choice}\\
        & ~|~ & \pseq{p}{p} & \text{sequence}\\
        & ~|~ & \children{p}{p} & \text{children}\\
        & ~|~ & \maybe{p} & \text{option}\\
        & ~|~ & \many{p} & \text{repetition}\\
        & ~|~ & \bind{p}{x} & \text{bind}\\
        & ~|~ & \paction{p}{f} & \text{action}\\
  \end{array}
\]

\subsection{Thoughts}

\begin{itemize}
\item We should really have choice (and conjunction?) at the
  top-level, to be able to allow, e.g.,
  $\por{(\pseq{\pin{\lbl}}{\textit{foo}})}{bar}$. We could allow
  negation of choice if we had conjunction at the top-level, but
  we do not want general negation...
\item We could have patterns $\mathit{lbls}$ and $!\mathit{lbls}$
  for disjunctive positive and conjunctive negative single term
  patterns respectively.
\item We could use the type system to say that you can get the
  children of anything as long as it has multiplicity $1$.
\item Should we allow overriding bindings? We could allow it in
  the matching semantics if we want well-formedness to be opt-in.
\item The \none{} pattern isn't quite right. We would like to have
  the property that if a pattern $p$ does not match, then the
  negation of the pattern \pnot{p} does match (and vice versa).
  The pattern \any{} does not match on the empty sequence, but
  neither does its negation \none{} (since it never matches).
  Similarly, \none{} does not match on the empty sequence, but
  neither does its negation \any{} (since it requires at least one
  term).
  \begin{itemize}
  \item Akhshualy, if you have an empty sequence, all $s$ patterns
    have the same issue as above! So maybe \none{} is back on the
    table.
  \end{itemize}
\item \any{} is equivalent to \por{\pnot{a}}{\pnot{b}} for
  disjoint $a$ and $b$.
\item Does it make sense to bind within $\fb{p}$?
\end{itemize}
%
Annoying things:

\begin{itemize}
\item We cannot define $\lnot(\lnot p) = p$, since that would
  require negation of general patterns, which does not make sense.
\item $|\lnot p| = |p|$ except for $\any$, where $|\lnot\any| = 0$
  \TODO{Actually, we could think of \any{} as ``match a single
    term with any label'', and then \pnot{\any{}} would be a
    pattern that never succeeds}
\end{itemize}
%
Possibly reasonable things:

\begin{itemize}
\item $\lnot \pin{\lbl}$
\item $\lnot (\pseq{p_1}{p_2})$, but that could also be
  $\pseq{\nfb{\pseq{p_1}{p_2}}}{\pseq{\any\times|p_1|}{\any\times|p_2|}}$
\end{itemize}
%
It does not make sense to negate patterns which always succeed,
i.e., option or repetition.

Things that appear in the wild
\begin{itemize}
\item
\begin{verbatim}
(~T(Brace) *
  (((T(Symbol) / T(Dot)) * T(Brace)) /
   (!(T(Brace) / T(TripleColon))))++)
\end{verbatim}
\item \texttt{((In(Top) * T(File)[Class]) / T(Directory)[Class])}
\item \texttt{(!(T(Brace) / T(TripleColon)))}
\item \texttt{(In(Top) / In(ClassBody) / In(Block))}
\item
\begin{verbatim}
(T(Plus) / T(Minus) / T(Mult) / T(Div)) << T(Expression)
\end{verbatim}
\end{itemize}

\section{Term Rewriting}


\section*{TODO}

\begin{itemize}
\item Top-down vs. Bottom-up
\item Regex matching (requires carrying data)
\item Well-formedness
\item Symbol tables?
\end{itemize}

\section*{Quiz}

\begin{verbatim}
((T(Foo) * T(Bar)) << Any[Id]) >>
  [](Match& _) { return _(Id); }

(foo a) (bar b) --> a
\end{verbatim}

\begin{verbatim}
(In(Foo) << Any[Id]) >>
  [](Match& _) { return _(Id); }

(foo a) (bar b) --> Segmentation fault
\end{verbatim}

\begin{verbatim}
((!In(Bar)) * T(Baz)) >>
  [](Match& _) { return NodeDef::create(Fr0b); }

(foo baz) --> fr0b
\end{verbatim}

\end{document}
